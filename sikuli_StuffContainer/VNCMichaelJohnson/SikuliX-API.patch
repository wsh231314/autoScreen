diff --git a/API/.classpath b/API/.classpath
new file mode 100644
index 0000000..f32149e
--- /dev/null
+++ b/API/.classpath
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" output="target/classes" path="src/main/java">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
diff --git a/API/.project b/API/.project
new file mode 100644
index 0000000..9196bbb
--- /dev/null
+++ b/API/.project
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SikuliX-API</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
+	</natures>
+</projectDescription>
diff --git a/API/.settings/org.eclipse.core.resources.prefs b/API/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..cf6931b
--- /dev/null
+++ b/API/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+encoding//src/main/java=UTF-8
+encoding//src/main/resources=UTF-8
+encoding/<project>=UTF-8
diff --git a/API/.settings/org.eclipse.jdt.core.prefs b/API/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..14f521d
--- /dev/null
+++ b/API/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,5 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/API/.settings/org.eclipse.m2e.core.prefs b/API/.settings/org.eclipse.m2e.core.prefs
new file mode 100644
index 0000000..14b697b
--- /dev/null
+++ b/API/.settings/org.eclipse.m2e.core.prefs
@@ -0,0 +1,4 @@
+activeProfiles=
+eclipse.preferences.version=1
+resolveWorkspaceProjects=true
+version=1
diff --git a/API/src/main/java/edu/unh/iol/dlc/ConnectionController.java b/API/src/main/java/edu/unh/iol/dlc/ConnectionController.java
new file mode 100644
index 0000000..96aa152
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/ConnectionController.java
@@ -0,0 +1,227 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.HeadlessException;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Locale;
+
+/**
+ * The ConnectionController class manages all of the VNC connections as well
+ *  as the local copies of the remote Framebuffers.  A thread (VNCThread) is
+ *  created to manage the data from each connection.  Connection
+ *  Controller also extends GraphicsEnvironment so that it can be used
+ *  with the Java2D API
+ *  
+ *  @author Mike Johnson
+ */
+public class ConnectionController extends GraphicsEnvironment {
+
+	protected ArrayList<VNCThread> threads = new ArrayList<VNCThread>();
+	
+	private static ArrayList<ConnectionController> cons = new ArrayList<ConnectionController>();
+	
+	/**
+	 * Constructor
+	 * 
+	 * @param sockets for connections
+	 */
+	public ConnectionController(Socket... sockets){
+		
+		for(int i = 0; i < sockets.length; i++){
+			threads.add(new VNCThread(sockets[i]));
+		}
+		
+		cons.add(this);
+	}
+	
+//Thread wrapper methods******************************************************/
+    
+	/**
+	 * Gets a protocol message object from the array at the given index
+	 * 
+	 * @param index
+	 * @return VNC protocol message object
+	 */
+	protected VNCClient getC(int index){
+		return threads.get(index).getClient();
+	}
+	
+	/**
+	 * Gets a local framebuffer object from the array at the given index
+	 * 
+	 * @param index
+	 * @return local framebuffer object
+	 */
+	protected Framebuffer getF(int index){
+		return threads.get(index).getScreen();
+	}
+	
+	/**
+	 * Tells one of the VNC Client Threads to connect to the VNC server
+	 */
+	public void openConnection(int index){
+		//since other security types are not yet supported
+		threads.get(index).openConnection(1, 1); 
+	}
+	
+	/**
+	 * Changes the rate at which one of the VNC Client Threads polls 
+	 * the server for changes
+	 */
+	public void changeUpdateInterval(int index, int milliseconds){
+		threads.get(index).changePollInterval(milliseconds);
+	}
+	
+	/**
+	 * Closes one of the VNC Client Threads and removes it from
+	 * the ArrayList
+	 */
+	public void closeConnection(int index){
+		threads.get(index).terminate();
+		threads.remove(index);
+	}
+	
+	/**
+	 * Sets the pixel format assoicated with one of the VNC 
+	 * Client Threads
+	 */
+	public void setPixelFormat(int index, String format, 
+			int bitsPerPixel, int bigEndianFlag) {
+		try {
+//			System.out.println("Setting Pixel format for thread: "+index);
+			threads.get(index).setPixelFormat(format, 
+					bitsPerPixel, bigEndianFlag);
+		}
+		catch (IOException io) {
+			System.err.println("Error: IO Exception"+io);
+		}
+	}
+	
+	/**
+	 * Adds a new VNCThread to the list of connections
+	 */
+	public void newConnection(Socket s){
+		threads.add(new VNCThread(s));
+	}
+	
+	public void start(int index){
+		threads.get(index).start();
+	}
+    
+//GraphicsEnvironment extension***********************************************/
+	
+	/**
+	 * Returns an active connection controller
+	 * 
+	 * @param index the index in the array
+	 * @return active connectioncontroller
+	 */
+	public static ConnectionController getActiveController(int index){
+		if(cons.isEmpty()){
+			return null;
+		}
+		return cons.get(index);
+	}
+	
+	/**
+	 * Returns an array of all of the screen devices
+	 * 
+	 * @return Array of screen devices
+	 */
+	@Override
+	public GraphicsDevice[] getScreenDevices() throws HeadlessException {
+		if(isHeadless()){
+			throw new HeadlessException();
+		}
+		Framebuffer[] fbs = new Framebuffer[threads.size()];
+		
+		for(int i = 0; i < fbs.length; i++){
+			fbs[i] = threads.get(i).getScreen();
+		}
+		
+		return fbs;
+	}
+
+	/**
+	 * Returns the default screen device
+	 * 
+	 * @return The default screen device
+	 */
+	@Override
+	public GraphicsDevice getDefaultScreenDevice() throws HeadlessException {
+		if(isHeadless()){
+			throw new HeadlessException();
+		}
+		return threads.get(0).getScreen();
+	}
+
+	/**
+	 * Returns a Graphics2D object used to render on the BufferedImage.
+	 * 
+	 * @param the BufferedImage
+	 * @return the Grpahics2D
+	 */
+	@Override
+	public Graphics2D createGraphics(BufferedImage img) {
+		return img.createGraphics();
+	}
+
+	/**
+	 * Returns an array of the fonts for the local graphics environement.
+	 * 
+	 * @return An array of fonts
+	 */
+	@Override
+	public Font[] getAllFonts() {
+		return GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
+	}
+
+	/**
+	 * Returns an array of the available font family names in the local
+	 * GraphicsEnvironment.
+	 * 
+	 * @return The array of names
+	 */
+	@Override
+	public String[] getAvailableFontFamilyNames() {
+		return GraphicsEnvironment.getLocalGraphicsEnvironment(
+				).getAvailableFontFamilyNames();
+	}
+
+	/**
+	 * Returns an array of the available font family names based on
+	 * a specific locale.
+	 * 
+	 * @return The array of names
+	 */
+	@Override
+	public String[] getAvailableFontFamilyNames(Locale l) {
+		return GraphicsEnvironment.getLocalGraphicsEnvironment(
+				).getAvailableFontFamilyNames(l);
+	}
+}
+
+
diff --git a/API/src/main/java/edu/unh/iol/dlc/FBConfig.java b/API/src/main/java/edu/unh/iol/dlc/FBConfig.java
new file mode 100644
index 0000000..877be71
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/FBConfig.java
@@ -0,0 +1,257 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.Rectangle;
+import java.awt.geom.AffineTransform;
+import java.awt.image.BufferedImage;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
+import java.awt.image.DataBufferInt;
+import java.awt.image.DirectColorModel;
+import java.awt.image.Raster;
+import java.awt.image.WritableRaster;
+
+/**
+ * The FBConfig class stores configuration information about the
+ * framebuffer
+ * 
+ * @author Mike Johnson
+ *
+ */
+public class FBConfig extends GraphicsConfiguration {
+	
+	private int width = 0;
+	private int height = 0;
+	private int bitsPerPixel = 0;
+	private int depth = 0;
+	private int bigEndianFlag = 0;
+	private int trueColorFlag = 0;
+	private int redMax = 0;
+	private int greenMax = 0;
+	private int blueMax = 0;
+	private int redShift = 0;
+	private int greenShift = 0;
+	private int blueShift = 0;
+	private Rectangle bounds;
+	private String desktopName = null;
+	private int idnum;
+	private ColorModel cm;
+	private DataBuffer db;
+
+	/**
+	 * Constructor
+	 * 
+	 * @param config the configuration information
+	 * @param name the remote desktop name
+	 */
+	public FBConfig(int[] config, String name){
+		width = config[0];
+		height = config[1];
+		bitsPerPixel = config[2];
+		depth = config[3];
+		bigEndianFlag = config[4];
+		trueColorFlag = config[5];
+		redMax = config[6];
+		greenMax = config[7];
+		blueMax = config[8];
+		redShift = config[9];
+		greenShift = config[10];
+		blueShift = config[11];
+		desktopName = name;
+		bounds = new Rectangle(0,0,width,height);
+		
+//		System.out.println("VNC Server Response:");
+//		for(int i : config){
+//			System.out.println(i);
+//		}
+//		System.out.println("Name: "+desktopName);
+		
+		switch(bitsPerPixel){
+			case 8:
+				if(trueColorFlag!=0){
+					idnum=3;
+					System.err.println("Error: Unsupported bits per pixel," +
+					" setPixelFormatRequired");
+				}
+				else{
+					idnum=0;
+					System.err.println("Error: Unsupported bits per pixel," +
+					" setPixelFormatRequired");
+				}
+				break;
+			case 16:
+				if(trueColorFlag!=0){
+					idnum=4;
+					System.err.println("Error: Unsupported bits per pixel," +
+					" setPixelFormatRequired");
+				}
+				else{
+					idnum=1;
+					System.err.println("Error: Unsupported bits per pixel," +
+					" setPixelFormatRequired");
+				}
+				break;
+			case 32:
+				if(trueColorFlag!=0){
+					idnum=5;
+					int[] bitMasks = new int[3];
+	    			bitMasks[0] = 0x00ff0000; //red mask-8 bits
+	    			bitMasks[1] = 0x0000ff00; //green mask-8 bits
+	    			bitMasks[2] = 0x000000ff; //blue mask-8 bits
+	    			cm = new DirectColorModel(32,bitMasks[0],bitMasks[1],bitMasks[2]);
+	    			db = new DataBufferInt(width*height);
+				}
+				else{
+					idnum=2;
+					System.err.println("Error: Unsupported bits per pixel," +
+					" setPixelFormatRequired");
+				}
+				break;
+			default:
+				System.err.println("Error: Unrecognized bits per pixel," +
+				" setPixelFormatRequired");
+				break;
+		}
+	}
+	
+	/**
+	 * Creates a compatible raster basted on this configuration
+	 * 
+	 * @return raster
+	 */
+	public Raster createCompatibleRaster(){
+		switch(idnum){
+			case 0:
+				return null;
+			case 1:
+				return null;
+			case 2:
+				return null;
+			case 3:
+				return null;
+			case 4:
+				return null;
+			case 5:
+				int[] bitMasks = new int[3];
+    			bitMasks[0] = 0x00ff0000; //red mask-8 bits
+    			bitMasks[1] = 0x0000ff00; //green mask-8 bits
+    			bitMasks[2] = 0x000000ff; //blue mask-8 bits
+				return WritableRaster.createPackedRaster(
+	    				db, width, height, width, bitMasks, null);
+			default:
+				return null;
+		}
+	}
+	
+	/**
+	 * Gets the id number of the configuration
+	 * 
+	 * @return num 0 colormap 8 bit
+	 * 			   1 colormap 16 bit
+	 * 			   2 colormap 32 bit
+	 * 			   3 truecolor 8 bit
+	 * 			   4 truecolor 16 bit
+	 * 			   5 truecolor 32 bit
+	 */
+	public int getIdNum(){
+		return idnum;
+	}
+	
+	/**
+	 * Gets the name of the remote desktop
+	 * 
+	 * @return name
+	 */
+	public String getName(){
+		return desktopName;
+	}
+	
+	
+	@Override
+	public GraphicsDevice getDevice() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	/**
+	 * Creates a compatible image with this configuration based off
+	 * a width and height
+	 */
+	@Override
+	public BufferedImage createCompatibleImage(int width, int height) {
+		switch(idnum){
+			case 0:
+				return null;
+			case 1:
+				return null;
+				//return new BufferedImage(width, height, BufferedImage.TYPE_CUSTOM);
+			case 2:
+				return null;
+				//return new BufferedImage(width, height, BufferedImage.TYPE_CUSTOM);
+			case 3:
+				return null;
+				//return new BufferedImage(width, height, BufferedImage.TYPE_CUSTOM);
+			case 4:
+				return new BufferedImage(width, height, BufferedImage.TYPE_USHORT_565_RGB);
+			case 5:
+				return new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+			default:
+				return new BufferedImage(width, height, BufferedImage.TYPE_CUSTOM);
+		}
+	}
+
+	/**
+	 * Gets the colormodel of this configuration
+	 */
+	@Override
+	public ColorModel getColorModel() {
+		return cm;
+	}
+
+	/**
+	 * Gets the colormodel of this configuration
+	 */
+	@Override
+	public ColorModel getColorModel(int transparency) {
+		return cm;
+	}
+
+	@Override
+	public AffineTransform getDefaultTransform() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public AffineTransform getNormalizingTransform() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	/**
+	 * Gets the bounds of the configuration
+	 */
+	@Override
+	public Rectangle getBounds() {
+		return bounds;
+	}
+
+}
diff --git a/API/src/main/java/edu/unh/iol/dlc/Framebuffer.java b/API/src/main/java/edu/unh/iol/dlc/Framebuffer.java
new file mode 100644
index 0000000..3607900
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/Framebuffer.java
@@ -0,0 +1,251 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.image.BufferedImage;
+import java.awt.image.WritableRaster;
+
+/**
+ * The framebuffer class is responsible for maintaining the local
+ * copy of the remote framebuffer.  The class extends GraphicsDevice
+ * so that it can be used with the java2D API.
+ * 
+ * @author Mike Johnson
+ */
+public class Framebuffer extends GraphicsDevice {
+	
+	/*
+     * Below are the fields associated with the 
+     * Server's PixelFormat and Framebuffer.
+     */
+	private FBConfig conf = null;
+	private BufferedImage buffer;
+	private int[][] rgbs = null;
+	private boolean updated = false;
+	private BufferedImage doubleBuffer;
+	
+//General methods*************************************************************/
+	
+	/**
+	 * Method that sets the pixel format of the framebuffer.
+	 * 
+	 * @param int[] sets the pixel format of the framebuffer for the connection
+	 * @param String name of the remote desktop
+	 * @return true if the pixel format is valid for what the VNC stack
+	 * 		   	    currently supports
+	 * 		   false if the pixel format is not valid
+	 */
+	protected boolean setPF(int[] data, String name){
+		
+		if(conf != null){
+			int[] array = {getWidth(), getHeight(), data[0],data[1],data[2],
+					data[3],data[4],data[5],data[6],data[7],data[8],data[9]};
+			conf = new FBConfig(array, name);
+		}
+		else{
+			conf = new FBConfig(data, name);
+		}
+		if(conf.getIdNum() == 5){
+			return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Resets the pixel format to a different configuration
+	 * 
+	 * @param int[] sets the pixel format of the framebuffer for the connection
+	 * @param String name of the remote desktop
+	 * @return true if the pixel format is valid for what the VNC stack
+	 * 		   	    currently supports
+	 * 		   false if the pixel format is not valid
+	 * 
+	 */
+	protected boolean resetPF(int[] data){
+		return setPF(data, conf.getName());
+	}
+	
+	/**
+	 * Gets the PixelFormat in the form of a GraphicsConfiguration
+	 * object
+	 * 
+	 * @return conf the GraphicsConfiguration
+	 */
+	protected GraphicsConfiguration getPF(){
+		return conf;
+	}
+	
+	/**
+	 * Gets the width of the framebuffer
+	 */
+	protected int getWidth(){
+		return conf.getBounds().width;
+	}
+	
+	/**
+	 * Gets the height of the framebuffer
+	 */
+	protected int getHeight(){
+		return conf.getBounds().height;
+	}
+	
+	/**
+	 * Sets the buffer according to the specified raster
+	 */
+	private synchronized void setBuffer(WritableRaster raster){
+		buffer = conf.createCompatibleImage(
+        		conf.getBounds().width, conf.getBounds().height);
+		buffer.setData(raster);
+		updated = true;
+		doubleBuffer = buffer;
+	}
+	
+	/**
+	 * Gets the buffer
+	 */
+	protected synchronized BufferedImage getBuffer(){
+		//return doubleBuffer;
+		if(updated){
+			updated=false;
+			return buffer;
+		}
+		return doubleBuffer;
+	}
+	
+//Raw Encoding Methods********************************************************/
+	
+	/**
+	 * Copies raw pixel array (which is actually a 
+	 * rectangle of pixel data) into the buffer.
+	 * 
+	 * @param x x location of origin of pixel rectangle
+	 * @param y y location of origin of pixel rectangle
+	 * @param w width of pixel rectangle
+	 * @param h height of pixel rectangle
+	 * @param input array containing pixel data
+	 */
+	protected void raw(int x, int y, int w,
+			int h, int[] input){
+		if(rgbs==null){
+			rgbs = new 
+			int[conf.getBounds().width*3][conf.getBounds().height];
+		}
+		int count = 0;
+		label:
+		for(int j=y;j<h+y;j++){
+			for(int i=(x*3);i<((w*3)+(x*3));i++){
+				//System.out.println(input[count]);
+				rgbs[i][j] = input[count];
+				count++;
+				if(count==input.length){
+					break label;
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Converts the pixel array into a buffered image
+	 */
+	protected void convertToBufferedImage(){
+		switch(conf.getIdNum()){
+		case 0:
+			//8bit colormap
+			System.err.println("Error: Config not supported");
+			break;
+		case 1:
+			//16bit colormap
+			System.err.println("Error: Config not supported");
+			break;
+		case 2:
+			//32bit colormap
+			System.err.println("Error: Config not supported");
+			break;
+		case 3:
+			//8bit truecolor
+			System.err.println("Error: Config not supported");
+			break;
+		case 4:
+			//16bit truecolor
+			System.err.println("Error: Config not supported");
+			break;
+		case 5:
+			//32bit truecolor
+			int[] rgbSamples = 
+				new int[conf.getBounds().width*conf.getBounds().height*3];
+			int count = 0;
+			for(int j = 0; j < (conf.getBounds().height); j++){
+				for(int i = 0; i < (conf.getBounds().width*3); i++){
+					rgbSamples[count] = rgbs[i][j]; 
+					count++;
+				}
+			}
+			WritableRaster raster = 
+				(WritableRaster)conf.createCompatibleRaster();
+			raster.setPixels(0, 0, conf.getBounds().width,
+					conf.getBounds().height, rgbSamples);
+	        setBuffer(raster);
+			break;
+		default:
+			System.err.println("Error: Config not supported");
+			break;
+		}
+	}
+	
+//CopyRect Encoding Methods***************************************************/
+	
+	/**
+	 * implements the copyrect encoding
+	 */
+	protected synchronized void copyRect(int x, int y, int w, int h,
+			int srcx, int srcy){
+    	BufferedImage sub = buffer.getSubimage(srcx, srcy, w, h);
+    	buffer.setData(sub.getRaster().createTranslatedChild(x, y));
+	}
+	
+//GraphicsDevice extension****************************************************/	
+
+	/**
+	 * Returns the type of GraphicsDevice for the Framebuffer
+	 */
+	@Override
+	public int getType() {
+		return GraphicsDevice.TYPE_RASTER_SCREEN;
+	}
+
+	/**
+	 * Returns the ID String for the Framebuffer
+	 */
+	@Override
+	public String getIDstring() {
+		return "RFB";
+	}
+
+	@Override
+	public GraphicsConfiguration[] getConfigurations() {
+		return new GraphicsConfiguration[] {conf};
+	}
+
+	@Override
+	public GraphicsConfiguration getDefaultConfiguration() {
+		return conf;
+	}
+
+}
diff --git a/API/src/main/java/edu/unh/iol/dlc/VNCClient.java b/API/src/main/java/edu/unh/iol/dlc/VNCClient.java
new file mode 100644
index 0000000..35b8538
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/VNCClient.java
@@ -0,0 +1,543 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.Socket;
+
+/**
+ * The VNCClient class controls all of the messages between
+ * the client and the server.
+ * 
+ * @author Mike Johnson
+ *
+ */
+public class VNCClient {
+	
+	/*
+     * Below are the fields and objects associated with the handshaking phase
+     */
+    private BufferedWriter out = null;
+    private BufferedReader in = null;
+    private DataOutputStream dataOut = null;
+    private DataInputStream dataIn = null;
+    private int version = 0;
+    private Socket socket = null;
+    private int bef;
+
+	/**
+     * Constructor
+     *
+     * @param soc  Socket to be used in VNC connection
+     */
+    public VNCClient(Socket soc){
+        socket = soc;
+        try{
+            socket.setTcpNoDelay(true);
+            out = new BufferedWriter(
+                new OutputStreamWriter(socket.getOutputStream(),"US-ASCII"));
+            in = new BufferedReader(
+                new InputStreamReader(socket.getInputStream(),"US-ASCII"));
+            dataOut = new DataOutputStream(
+                new BufferedOutputStream(socket.getOutputStream()));
+            dataIn = new DataInputStream(
+                new BufferedInputStream(socket.getInputStream()));
+        }
+        catch(IOException e){
+            System.err.println("Error: IO Exception"+e);
+        }
+    }
+    
+//Handshaking Phase*****************************************************************************/
+    
+    /* Below are all of the methods associated with the establishing the VNC
+     * Connection.
+     */
+
+    /**
+     * This method reads the Protocol Version message from the server and then
+     * selects the highest protocol version supported by the server.  If an
+     * unrecognized protocol version is sent, the client closes the connection.
+     * The encoding of the Protocol Version message is 7-bit ASCII.
+     *
+     */
+    protected void protocolHandshake()throws IOException{
+        MARKER:
+        try{
+            String protocolVersion = in.readLine();
+            version = Integer.parseInt(protocolVersion.substring(10, 11));
+            switch (version){
+                case 3:break;
+                case 7:break;
+                case 8:break;
+                default:
+                    System.err.println(
+                        "Error: Unrecognized protocol version," +
+                        " closing connection"+version);
+                    socket.close();
+                    break MARKER;
+            }
+            out.write(protocolVersion+"\n");
+            out.flush();
+            out = null; //so it gets collected
+            in = null;
+        }
+        catch(NumberFormatException n){
+        	System.err.println("Error: Number Format Exception"+n);
+        }
+    }
+
+    /**
+     * This method handles the initial security message exchanges between the
+     * client and the server.  If RFB 3.3 is used the server will select the
+     * security type and tell the client.  Otherwise the server will list the
+     * security types that it supports and the client will select the one it
+     * wants to use. If there is an error the server tells the client and the
+     * client prints the reason to the standard error.
+     *
+     * @param desiredSecurityType The desired security type as defined by
+     *                            the standard.
+     * @return selectedType If there is an IOerror the method returns a -1,
+     *                      otherwise it returns the security type selected
+     *                      for use.
+     */
+    protected int securityInit(int desiredSecurityType) throws IOException{
+        int selectedType = 0;
+        byte[] securityTypes = new byte[10];
+         if (version >= 7){
+            int numSecurityTypes = (int)dataIn.readByte();
+            if (numSecurityTypes == 0){
+                System.err.println("Error: Server reported" +
+                        " an error, closing connection");
+                socket.close();
+            }
+            dataIn.read(securityTypes,0,numSecurityTypes);
+            boolean flag = false;
+            for(int i = 0; i < securityTypes.length; i++){
+                if (securityTypes[i]==desiredSecurityType){
+                    flag = true;
+                    dataOut.write((byte)desiredSecurityType);
+                    dataOut.flush();
+                    break;
+                }
+            }
+            if(flag){
+                selectedType = desiredSecurityType;
+                return selectedType;
+            }
+            System.err.println("Error: Desired Security Type" +
+                        " Not supported by Server, closing connection");
+            socket.close();
+        }
+        else{
+            selectedType = dataIn.readInt();
+            return selectedType;
+        }
+        return selectedType;
+}
+
+    /**
+     * Method that takes the selected security type and calls the necessary
+     * methods involved with that security type.
+     *
+     * @param type The security type to be used as defined in the standard
+     */
+    protected void securityMethod(int type){
+        switch (type){
+            case 0:
+                try{
+                    System.err.println("Error: Server" +
+                        " reported an error, closing connection");
+                    socket.close();
+                }
+                catch(IOException e){
+                	System.err.println("Error: IO Exception"+e);
+                }
+                break;
+            case 1:
+                if(version == 8){
+                    securityResult();
+                }
+                break;
+            case 2:
+                /* TODO: Add VNC Authentication.
+                 * From the 3.8 standard:
+                 * "VNC authentication is to be used and protocol data is to be
+                 * sent unencrypted. The server sends a random 16-byte
+                 * challenge,the client encrypts the challenge with DES using
+                 * a password supplied by the user as the key, and sends the
+                 * resulting 16-byte response.
+                 * The protocol continues with the SecurityResult message."
+                 */
+                //securityResult();
+                break;
+            default:
+                try{
+                    System.err.println("Error: Desired Security" +
+                            " Type Not supported, closing connection");
+                    socket.close();
+                }
+                catch(IOException e){
+                	System.err.println("Error: IO Exception"+e);
+                }
+                break;
+        }
+    }
+
+    /**
+     * Handles the server's response to how the security handshaking went.
+     */
+    protected void securityResult(){
+        try{
+            int securityResult = dataIn.readInt();
+            if(securityResult == 1){
+                System.err.println(
+                        "Error: Server reported an error, closing connection");
+                socket.close();
+            }
+        }
+        catch(IOException e){
+        	System.err.println("Error: IO Exception"+e);
+        }
+    }
+
+    /**
+     * Method that tells the server whether to share
+     * the connection with others.
+     *
+     * @param share 1 Share the connection with other clients
+     *              0 Do not share the connection
+     */
+    protected void clientInit(int share) throws IOException,
+    InterruptedException{
+        dataOut.writeByte(share);
+        dataOut.flush();
+    }
+
+    /**
+     * Method that listens to the ServerInit message and records information
+     * about the framebuffer.
+     * 
+     * @return framebuffer information 
+     */
+    protected synchronized int[] listenServerInit() throws IOException,
+    InterruptedException{
+    	int[] data = {0,0,0,0,0,0,0,0,0,0,0,0};
+    	data[0]  = dataIn.readUnsignedShort();  //width
+    	data[1]  = dataIn.readUnsignedShort();  //height
+        data[2]  = dataIn.readUnsignedByte();   //bitsPerPixel
+        data[3]  = dataIn.readUnsignedByte();   //depth
+        data[4]  = dataIn.readUnsignedByte();   //bigEndianFlag
+        bef = data[4]; //for use later
+        data[5]  = dataIn.readUnsignedByte();   //trueColorFlag
+        data[6]  = dataIn.readUnsignedShort();  //redMax
+        data[7]  = dataIn.readUnsignedShort();  //greenMax
+        data[8]  = dataIn.readUnsignedShort();  //blueMax
+        data[9]  = dataIn.readUnsignedByte();   //redShift
+        data[10] = dataIn.readUnsignedByte();   //greenShift
+        data[11] = dataIn.readUnsignedByte();   //blueShift
+        dataIn.readUnsignedByte();
+        dataIn.readUnsignedByte(); //padding
+        dataIn.readUnsignedByte();
+        return data;
+    }
+    
+    /**
+     * Method that reads the desktop name of the remote host.
+     * 
+     * @return The name of the desktop
+     * @throws IOException
+     */
+    protected synchronized String readDesktopName() throws IOException{
+    	int nameLength = dataIn.readInt();
+        byte[] stringBytes = new byte[nameLength];
+        dataIn.read(stringBytes); //desktopName
+        return new String(stringBytes,"UTF-8");
+    }
+	
+//VNC Messages****************************************************************/
+    
+    /* Below are all of the methods the VNC Client can perform once connected.
+     */
+    
+    /**
+     * The SetPixelFormat message sets the format of the raw pixel data sent
+     * across the network by the VNC Server. See RFB 3.8 standard for 
+     * SelPixelFormat message.
+     *
+     * @param bpp The number of bits per pixel
+     * @param Depth The number of bits used for data
+     * @param bef The big endian flag
+     * @param tcf The true color flag
+     * @param rm The maximum red value
+     * @param gm The maximum blue value
+     * @param bm The maximum green value
+     * @param rs The red shift value
+     * @param gs The green shift value
+     * @param bs The blue shift value
+     * @throws IOException If there is a socket error.
+     */
+    protected void setPixelFormat(int bpp, int Depth, int be, int tcf, int rm,
+            int gm, int bm, int rs, int gs, int bs)throws IOException{
+    	dataOut.writeByte(0); //message identifier
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(bpp);
+        dataOut.writeByte(Depth);
+        dataOut.writeByte(be);
+        dataOut.writeByte(tcf);
+        dataOut.writeShort(rm);
+        dataOut.writeShort(gm);
+        dataOut.writeShort(bm);
+        dataOut.writeByte(rs);
+        dataOut.writeByte(gs);
+        dataOut.writeByte(bs);
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        bef = be;
+        dataOut.flush();
+    }
+    
+    /**
+     * Sets the encoding of the pixel data sent by the server. See standard
+     * for details of encoding type.
+     *
+     * @param numberOfEncodings The number of encodings the server supports
+     * @param encoding The value representing an encoding type.
+     * @throws IOException If there is a socket error.
+     */
+    protected void setEncodings(short numberOfEncodings,
+            int... encoding) throws IOException{
+        dataOut.writeByte(2); //message identifier
+        dataOut.writeByte(0); //padding
+        dataOut.writeShort(numberOfEncodings);
+        for(int index : encoding){
+            dataOut.writeInt(index);
+        }
+        dataOut.flush();
+    }
+
+    /**
+     * Sends FramebufferUpdateRequest message to server.
+     *
+     * @param incremental Zero sends entire desktop, One sends changes only.
+     * @param x X coordinate of desired region
+     * @param y Y coordinate of desired region
+     * @param w Width of desired region
+     * @param h Height of desired region
+     * @throws IOException If there is a socket error
+     */
+    protected void framebufferUpdateRequest(boolean flag, 
+    		int incremental,short x, short y,
+            short w, short h) throws IOException{
+    	if(flag == true){
+    		System.err.println("Error: SetPixelFormat Required.");
+    		return;
+    	}
+        dataOut.writeByte(3); //message identifier
+        dataOut.writeByte(incremental);
+        dataOut.writeShort(x);
+        dataOut.writeShort(y);
+        dataOut.writeShort(w);
+        dataOut.writeShort(h);
+        dataOut.flush();
+    }
+
+    /**
+     * Tells VNC server to depress key.
+     *
+     * @param key X Window System Keysym for key.
+     * @throws IOException If there is a socket error.
+     */
+    protected void keyDown(int key) throws IOException{
+        dataOut.writeByte(4); //message identifier
+        dataOut.writeByte(1); //key down flag
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        dataOut.writeInt(key);
+        dataOut.flush();
+        //System.out.println("Writing key down-"+Integer.toHexString(key));
+    }
+
+    /**
+     * Tells VNC server to release key.
+     *
+     * @param key X Window System Keysym for key.
+     * @throws IOException If there is a socket error.
+     */
+    protected void keyUp(int key) throws IOException{
+        dataOut.writeByte(4); //message identifier
+        dataOut.writeByte(0); //key up flag
+        dataOut.writeByte(0); //padding
+        dataOut.writeByte(0); //padding
+        dataOut.writeInt(key);
+        dataOut.flush();
+        //System.out.println("Writing key up-"+Integer.toHexString(key));
+    }
+
+    /**
+     * Tells VNC server to perform a mouse event. bOne through bEight are mouse
+     * buttons one through eight respectively.  A zero means release that
+     * button, and a one means depress that button.
+     *
+     * @param bOne Button One
+     * @param bTwo Button Two
+     * @param bThree Button Three
+     * @param bFour Button Four
+     * @param bFive Button Five
+     * @param bSix Button Six
+     * @param bSeven Button Seven
+     * @param bEight Button Eight
+     * @param x X coordinate of action
+     * @param y Y coordinate of action
+     * @throws IOException If there is a socket error.
+     */
+    protected void mouseEvent(int bOne,int bTwo,int bThree,
+            int bFour,int bFive,int bSix,int bSeven,
+            int bEight, int x,int y)throws IOException{
+        int[] buttons = {bOne,bTwo,bThree,bFour,
+        bFive,bSix,bSeven,bEight};
+        byte flag = 0;
+        for(int i = 0; i < 8; i++){
+            flag += buttons[i] << (i);
+        }
+        dataOut.writeByte(5);
+        dataOut.writeByte(flag);
+        dataOut.writeShort(x);
+        dataOut.writeShort(y);
+        dataOut.flush();
+        //System.out.println("MouseEvent-"+Byte.toString(flag));
+    }
+
+    /**
+     * TODO: Method to cut and paste text over VNC connection with
+     *
+     * @param text
+     * @throws IOException
+     */
+   protected void clientPasteText(String text)throws IOException{
+        byte[] b = text.getBytes("ISO-8859-1");
+        dataOut.writeByte(6);
+        dataOut.writeByte(0);
+        dataOut.writeByte(0);
+        dataOut.writeByte(0);
+        dataOut.writeInt(b.length);
+        for(int i = 0; i < b.length; i++){
+            dataOut.writeByte(b[i]);
+        }
+        dataOut.flush();
+    }
+    
+    /**
+     * Reads a single unsigned byte off of the wire
+     * 
+     * @return int the unsigned byte
+     * @throws IOException
+     */
+    protected synchronized int readByte() throws IOException{
+    	return dataIn.readUnsignedByte();
+    }
+    
+    /**
+     * Reads an unsigned short off of the wire
+     * 
+     * @return int the unsigned short
+     * @throws IOException
+     */
+    protected synchronized int readShort() throws IOException{
+    	return dataIn.readUnsignedShort();
+    }
+    
+    /**
+     * Reads an int off of the wire
+     * 
+     * @return int the int
+     * @throws IOException
+     */
+    protected synchronized int readInt() throws IOException{
+    	return dataIn.readInt();
+    }
+    
+    /**
+     * Reads truecolor 32 bit data off of the wire
+     * 
+     * @param length of the data
+     * @return int[] the data
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    protected synchronized int[] readTC32Data(int length)throws IOException, InterruptedException{
+		int[] input = new int[length];
+		if(bef > 0){ //big endian
+			for(int j = 0; j < length; j+=3){
+    			dataIn.readUnsignedByte();
+    			input[j] = dataIn.readUnsignedByte();
+    			input[j+1] = dataIn.readUnsignedByte();
+    			input[j+2] = dataIn.readUnsignedByte();
+    		}
+		}
+		else{ //little endian
+			for(int j = 0; j < length; j+=3){
+    			input[j+2] = dataIn.readUnsignedByte();
+    			input[j+1] = dataIn.readUnsignedByte();
+    			input[j] = dataIn.readUnsignedByte();
+    			dataIn.readUnsignedByte();
+    		}
+		}	
+		return input;
+	}
+    
+    /**
+     * Closes the connection
+     * 
+     * @throws IOException
+     */
+    protected void close() throws IOException{
+    	socket.close();
+    }
+    
+    /**
+     * Returns true if there is data waiting to be read from the socket
+     * 
+     * @return
+     * @throws IOException
+     */
+    protected boolean available() throws IOException{
+    	if(dataIn.available() > 0){
+    		return true;
+    	}
+    	return false;
+    }
+    
+    /**
+     * Returns the VNCClient Object as a string
+     */
+    public String toString(){
+    	return "VNCClient: Socket: "+socket.toString();
+    }
+}
diff --git a/API/src/main/java/edu/unh/iol/dlc/VNCRobot.java b/API/src/main/java/edu/unh/iol/dlc/VNCRobot.java
new file mode 100644
index 0000000..c1cf49e
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/VNCRobot.java
@@ -0,0 +1,842 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.GraphicsDevice;
+import java.awt.Rectangle;
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+
+import org.sikuli.script.IRobot;
+import org.sikuli.script.IScreen;
+import org.sikuli.script.Location;
+import org.sikuli.script.ScreenImage;
+import org.sikuli.basics.*;
+
+
+/**
+ * VNCRobot is an implementation of the IRobot interface
+ * that controls the VNC stack through a connection controller.
+ */
+public class VNCRobot implements IRobot {
+	
+	private ConnectionController con;
+	private int index;
+	private boolean shiftFlag = false;
+	/**
+	 * Constructor. Only accepts Framebuffer GraphicsDevices
+	 */
+	public VNCRobot(GraphicsDevice gDev) throws AWTException{
+		if(gDev instanceof Framebuffer){
+			con = ConnectionController.getActiveController(0);
+			for(int i = 0; i < con.threads.size(); i++){
+				if(gDev == con.getF(i)){
+					index = i;
+				}
+			}
+		}
+		else{
+			throw new AWTException("Error cannot instantiate Robot" +
+					" for non-remote screen");
+		}
+	}
+
+//IRobot implementation*******************************************************/
+	
+	//last positions of mouse cursor
+    private int last_x = -1;
+    private int last_y = -1;
+    private int autodelay = 0;
+    private boolean waitForIdle = false;
+    final static int MAX_DELAY = 60000;
+	
+	/**
+     * Presses a key
+     * 
+     * @param keycode the key
+     */
+    @Override
+    public void keyDown(int keycode){
+    	if(keycode == KeyEvent.VK_SHIFT){
+    		shiftFlag = true;
+    		return;
+    	}
+    	int key = getKeysym(keycode);
+    	if(key == 0xffffff){
+    		System.err.println("Error: Key not supprted-"+keycode);
+    	}
+        else{
+            try{
+               con.getC(index).keyDown(key);
+            }
+            catch(IOException e){
+               System.err.println("Cannot KeyDown: "+e);
+            }
+        }
+        tidyUp();
+    }
+
+    /**
+     * Releases a key
+     * 
+     * @param keycode the key
+     */
+    @Override
+    public void keyUp(int keycode){
+    	if(keycode==KeyEvent.VK_SHIFT){
+    		shiftFlag = false;
+    		return;
+    	}
+    	int key = getKeysym(keycode);
+        if(key==0xffffff){
+            System.err.println("Key not supported "+keycode);
+        }
+        else{
+            try{
+            	con.getC(index).keyUp(key);
+            }
+            catch(IOException e){
+                System.err.println("Cannot KeyUp: "+e);
+            }
+        }
+        tidyUp();
+    }
+
+    /**
+     * Moves the mouse to the specified x and y position.
+     * 
+     * @param x X coordinate
+     * @param y Y coordinate
+     */
+    @Override
+    public void mouseMove(int x, int y){
+    	try{
+    		con.getC(index).mouseEvent(0, 0, 0, 0, 0, 0, 0, 0, x, y);
+    	}
+    	catch(IOException e){
+    		System.err.println("Cannot generate mouse event: "+e);
+    	}
+    	last_x = x;
+		last_y = y;
+    	tidyUp();
+    }
+
+    /**
+     * Presses a mouse button at the current location
+     * 
+     * @param button can be InputEvent.BUTTON1_MASK
+	 *						InputEvent.BUTTON2_MASK
+	 *						InputEvent.BUTTON3_MASK
+     */
+	@Override
+	public void mouseDown(int buttons) {
+		int[] b = {0,0,0,0,0,0,0,0};
+        switch(buttons){
+                case InputEvent.BUTTON1_MASK: b[0]=1; break;
+                case InputEvent.BUTTON2_MASK: b[1]=1; break;
+                case InputEvent.BUTTON3_MASK: b[2]=1; break;
+                default: throw new IllegalArgumentException();
+        }
+        try{
+        	con.getC(index).mouseEvent(b[0], b[1], b[2],
+                    b[3], b[4], b[5], b[6], b[7], last_x, last_y);
+        }
+        catch(IOException e){
+            System.err.println("Cannot generate mouse event: "+e);
+        }
+        tidyUp();
+	}
+
+	/**
+     * Releases mouse buttons at last_x and last_y positions
+     * 
+     */
+	@Override
+	public int mouseUp(int buttons) {
+		try{
+			con.getC(index).mouseEvent(0,0,0,0,0,0,0,0, last_x, last_y);
+        }
+        catch(IOException e){
+            System.err.println("Cannot generate mouse event: "+e);
+        }
+        tidyUp();
+        
+        return 0;
+	}
+
+	/**
+     * Method moves the mouse wheel at an x and y position an indicated amount.
+     * If wheelAmt is positive the wheel moves up, if it is
+     * negative, it moves down.
+     *
+     * @param wheelAmt Amount to move wheel
+     */
+	@Override
+	public void mouseWheel(int wheelAmt) {
+		if(wheelAmt > 0){
+            for(int i=0 ; i < wheelAmt; i++){
+                try{
+                	con.getC(index).mouseEvent(0,0,0,0,1,0,0,0,last_x,last_y);
+                	con.getC(index).mouseEvent(0,0,0,0,0,0,0,0,last_x,last_y);
+                }
+                catch(IOException e){
+                    System.err.println("Cannot generate mouse event: "+e);
+                }
+            }
+        }
+        else{
+            for(int j = 0; j > (-wheelAmt); j--){
+                try{
+                	con.getC(index).mouseEvent(0,0,0,1,0,0,0,0,last_x,last_y);
+                	con.getC(index).mouseEvent(0,0,0,0,0,0,0,0,last_x,last_y);
+                }
+                catch(IOException e){
+                    System.err.println("Cannot generate mouse event: "+e);
+                }
+            }
+        }
+		tidyUp();
+	}
+
+	/**
+	 * Creates a screen capture of the remote screen.
+	 * 
+	 * @param screenRect - region to capture
+	 * @return ScreenImage of the remote screen
+	 */
+	@Override
+	public ScreenImage captureScreen(Rectangle screenRect) {
+		return new ScreenImage(screenRect,
+				con.getF(index).getBuffer().getSubimage(
+						screenRect.x, screenRect.y, 
+						screenRect.width, screenRect.height));
+	}
+
+	/**
+	 * Returns a BufferedImage of the specified rectangle on the
+	 * remote desktop
+	 * 
+	 * @param rect
+	 * @return
+	 */
+	public BufferedImage capture(Rectangle rect){
+		return con.getF(index).getBuffer().getSubimage(
+				rect.x, rect.y, 
+				rect.width, rect.height);
+	}
+	
+	/**
+	 * Waits until all events are processed.
+	 */
+	@Override
+	public void waitForIdle() {
+		try {
+			new java.awt.Robot().waitForIdle();
+		}
+		catch (AWTException e) {
+			System.err.println("Error-could non instantiate robot: "+e);
+		}
+	}
+
+	/**
+	 * Sleeps for the specified time.
+	 */
+	@Override
+	public void delay(int ms) {
+		if(ms < 0){
+			ms = 0;
+		}
+		if(ms > MAX_DELAY){
+			ms = MAX_DELAY;
+		}
+		try{
+			Thread.sleep(ms);
+		}
+		catch(InterruptedException e){
+			System.err.println("Thread Interrupted: "+e);
+		}
+	}
+
+	/**
+	 * Sets the number of milliseconds this Robot sleeps after generating an event.
+	 */
+	@Override
+	public void setAutoDelay(int ms) {
+		if(ms < 0){
+			ms = 0;
+		}
+		if(ms > MAX_DELAY){
+			ms = MAX_DELAY;
+		}
+		autodelay = ms;
+	}
+	
+	/**
+	 * drags and drops the mouse
+	 */
+	public void dragDrop(Location start,Location end,int steps,long ms,int buttons){
+        mouseMove(start.x, start.y);
+	    mouseDown(buttons);
+	    delay((int)(Settings.DelayAfterDrag*1000));
+	    waitForIdle();
+	    smoothMove(start, end, ms);
+	    delay((int)(Settings.DelayBeforeDrop*1000));
+	    mouseUp(buttons);
+	    waitForIdle();
+	}
+	
+	/**
+	 * Types the specified keyCodes based on a certain KeyMode
+	 * 
+	 * @param mode     KeyMode.PRESS_ONLY
+	 * 				   KeyMode.RELEASE_ONLY
+	 * 				   KeyMode.PRESS_RELEASE
+	 * @param keyCodes KeyEvent
+	 */
+	protected void doType(KeyMode mode, int... keyCodes) {
+	      if(mode==KeyMode.PRESS_ONLY){
+	         for(int i=0;i<keyCodes.length;i++){
+	            keyDown(keyCodes[i]);
+	         }
+	      }
+	      else if(mode==KeyMode.RELEASE_ONLY){
+	         for(int i=0;i<keyCodes.length;i++){
+	            keyUp(keyCodes[i]);
+	         }
+	      }
+	      else{
+	         for(int i=0;i<keyCodes.length;i++)
+	            keyDown(keyCodes[i]);
+	         for(int i=0;i<keyCodes.length;i++)
+	            keyUp(keyCodes[i]);
+	      }
+	   }
+	
+	@Override
+	   public void typeChar(char character, KeyMode mode) {
+	      switch (character) {
+	         case 'a'     : doType(mode,KeyEvent.VK_A); break;
+	         case 'b'     : doType(mode,KeyEvent.VK_B); break;
+	         case 'c'     : doType(mode,KeyEvent.VK_C); break;
+	         case 'd'     : doType(mode,KeyEvent.VK_D); break;
+	         case 'e'     : doType(mode,KeyEvent.VK_E); break;
+	         case 'f'     : doType(mode,KeyEvent.VK_F); break;
+	         case 'g'     : doType(mode,KeyEvent.VK_G); break;
+	         case 'h'     : doType(mode,KeyEvent.VK_H); break;
+	         case 'i'     : doType(mode,KeyEvent.VK_I); break;
+	         case 'j'     : doType(mode,KeyEvent.VK_J); break;
+	         case 'k'     : doType(mode,KeyEvent.VK_K); break;
+	         case 'l'     : doType(mode,KeyEvent.VK_L); break;
+	         case 'm'     : doType(mode,KeyEvent.VK_M); break;
+	         case 'n'     : doType(mode,KeyEvent.VK_N); break;
+	         case 'o'     : doType(mode,KeyEvent.VK_O); break;
+	         case 'p'     : doType(mode,KeyEvent.VK_P); break;
+	         case 'q'     : doType(mode,KeyEvent.VK_Q); break;
+	         case 'r'     : doType(mode,KeyEvent.VK_R); break;
+	         case 's'     : doType(mode,KeyEvent.VK_S); break;
+	         case 't'     : doType(mode,KeyEvent.VK_T); break;
+	         case 'u'     : doType(mode,KeyEvent.VK_U); break;
+	         case 'v'     : doType(mode,KeyEvent.VK_V); break;
+	         case 'w'     : doType(mode,KeyEvent.VK_W); break;
+	         case 'x'     : doType(mode,KeyEvent.VK_X); break;
+	         case 'y'     : doType(mode,KeyEvent.VK_Y); break;
+	         case 'z'     : doType(mode,KeyEvent.VK_Z); break;
+	         case 'A'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_A); break;
+	         case 'B'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_B); break;
+	         case 'C'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_C); break;
+	         case 'D'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_D); break;
+	         case 'E'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_E); break;
+	         case 'F'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_F); break;
+	         case 'G'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_G); break;
+	         case 'H'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_H); break;
+	         case 'I'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_I); break;
+	         case 'J'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_J); break;
+	         case 'K'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_K); break;
+	         case 'L'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_L); break;
+	         case 'M'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_M); break;
+	         case 'N'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_N); break;
+	         case 'O'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_O); break;
+	         case 'P'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_P); break;
+	         case 'Q'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_Q); break;
+	         case 'R'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_R); break;
+	         case 'S'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_S); break;
+	         case 'T'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_T); break;
+	         case 'U'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_U); break;
+	         case 'V'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_V); break;
+	         case 'W'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_W); break;
+	         case 'X'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_X); break;
+	         case 'Y'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_Y); break;
+	         case 'Z'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_Z); break;
+	         case '`'     : doType(mode,KeyEvent.VK_BACK_QUOTE); break;
+	         case '0'     : doType(mode,KeyEvent.VK_0); break;
+	         case '1'     : doType(mode,KeyEvent.VK_1); break;
+	         case '2'     : doType(mode,KeyEvent.VK_2); break;
+	         case '3'     : doType(mode,KeyEvent.VK_3); break;
+	         case '4'     : doType(mode,KeyEvent.VK_4); break;
+	         case '5'     : doType(mode,KeyEvent.VK_5); break;
+	         case '6'     : doType(mode,KeyEvent.VK_6); break;
+	         case '7'     : doType(mode,KeyEvent.VK_7); break;
+	         case '8'     : doType(mode,KeyEvent.VK_8); break;
+	         case '9'     : doType(mode,KeyEvent.VK_9); break;
+	         case '-'     : doType(mode,KeyEvent.VK_MINUS); break;
+	         case '='     : doType(mode,KeyEvent.VK_EQUALS); break;
+	         case '~'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_BACK_QUOTE); break;
+	         case '!'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_1); break;
+	         case '@'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_2); break;
+	         case '#'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_3); break;
+	         case '$'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_4); break;
+	         case '%'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_5); break;
+	         case '^'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_6); break;
+	         case '&'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_7); break;
+	         case '*'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_8); break;
+	         case '('     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_9); break;
+	         case ')'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_0); break;
+	         case '_'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_MINUS); break;
+	         case '+'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_EQUALS); break;
+	         case '\b'    : doType(mode,KeyEvent.VK_BACK_SPACE); break;
+	         case '\t'    : doType(mode,KeyEvent.VK_TAB); break;
+	         case '\r'    : doType(mode,KeyEvent.VK_ENTER); break;
+	         case '\n'    : doType(mode,KeyEvent.VK_ENTER); break;
+	         case '['     : doType(mode,KeyEvent.VK_OPEN_BRACKET); break;
+	         case ']'     : doType(mode,KeyEvent.VK_CLOSE_BRACKET); break;
+	         case '\\'    : doType(mode,KeyEvent.VK_BACK_SLASH); break;
+	         case '{'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_OPEN_BRACKET); break;
+	         case '}'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_CLOSE_BRACKET); break;
+	         case '|'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_BACK_SLASH); break;
+	         case ';'     : doType(mode,KeyEvent.VK_SEMICOLON); break;
+	         case ':'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_SEMICOLON); break;
+	         case '\''    : doType(mode,KeyEvent.VK_QUOTE); break;
+	         case '"'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_QUOTE); break;
+	         case ','     : doType(mode,KeyEvent.VK_COMMA); break;
+	         case '<'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_COMMA); break;
+	         case '.'     : doType(mode,KeyEvent.VK_PERIOD); break;
+	         case '>'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_PERIOD); break;
+	         case '/'     : doType(mode,KeyEvent.VK_SLASH); break;
+	         case '?'     : doType(mode,KeyEvent.VK_SHIFT, KeyEvent.VK_SLASH); break;
+	         case ' '     : doType(mode,KeyEvent.VK_SPACE); break;
+	         case '\u001b': doType(mode,KeyEvent.VK_ESCAPE); break;
+	         case '\ue000': doType(mode,KeyEvent.VK_UP); break;
+	         case '\ue001': doType(mode,KeyEvent.VK_RIGHT); break;
+	         case '\ue002': doType(mode,KeyEvent.VK_DOWN); break;
+	         case '\ue003': doType(mode,KeyEvent.VK_LEFT); break;
+	         case '\ue004': doType(mode,KeyEvent.VK_PAGE_UP); break;
+	         case '\ue005': doType(mode,KeyEvent.VK_PAGE_DOWN); break;
+	         case '\ue006': doType(mode,KeyEvent.VK_DELETE); break;
+	         case '\ue007': doType(mode,KeyEvent.VK_END); break;
+	         case '\ue008': doType(mode,KeyEvent.VK_HOME); break;
+	         case '\ue009': doType(mode,KeyEvent.VK_INSERT); break;
+	         case '\ue011': doType(mode,KeyEvent.VK_F1); break;
+	         case '\ue012': doType(mode,KeyEvent.VK_F2); break;
+	         case '\ue013': doType(mode,KeyEvent.VK_F3); break;
+	         case '\ue014': doType(mode,KeyEvent.VK_F4); break;
+	         case '\ue015': doType(mode,KeyEvent.VK_F5); break;
+	         case '\ue016': doType(mode,KeyEvent.VK_F6); break;
+	         case '\ue017': doType(mode,KeyEvent.VK_F7); break;
+	         case '\ue018': doType(mode,KeyEvent.VK_F8); break;
+	         case '\ue019': doType(mode,KeyEvent.VK_F9); break;
+	         case '\ue01A': doType(mode,KeyEvent.VK_F10); break;
+	         case '\ue01B': doType(mode,KeyEvent.VK_F11); break;
+	         case '\ue01C': doType(mode,KeyEvent.VK_F12); break;
+	         case '\ue01D': doType(mode,KeyEvent.VK_F13); break;
+	         case '\ue01E': doType(mode,KeyEvent.VK_F14); break;
+	         case '\ue01F': doType(mode,KeyEvent.VK_F15); break;
+	         case '\ue020': doType(mode,KeyEvent.VK_SHIFT); break;
+	         case '\ue021': doType(mode,KeyEvent.VK_CONTROL); break;
+	         case '\ue022': doType(mode,KeyEvent.VK_ALT); break;
+	         case '\ue023': doType(mode,KeyEvent.VK_META); break;
+	         case '\ue024': doType(mode,KeyEvent.VK_PRINTSCREEN); break;
+	         case '\ue025': doType(mode,KeyEvent.VK_SCROLL_LOCK); break;
+	         case '\ue026': doType(mode,KeyEvent.VK_PAUSE); break;
+	         case '\ue027': doType(mode,KeyEvent.VK_CAPS_LOCK); break;
+	         case '\ue030': doType(mode,KeyEvent.VK_NUMPAD0); break;
+	         case '\ue031': doType(mode,KeyEvent.VK_NUMPAD1); break;
+	         case '\ue032': doType(mode,KeyEvent.VK_NUMPAD2); break;
+	         case '\ue033': doType(mode,KeyEvent.VK_NUMPAD3); break;
+	         case '\ue034': doType(mode,KeyEvent.VK_NUMPAD4); break;
+	         case '\ue035': doType(mode,KeyEvent.VK_NUMPAD5); break;
+	         case '\ue036': doType(mode,KeyEvent.VK_NUMPAD6); break;
+	         case '\ue037': doType(mode,KeyEvent.VK_NUMPAD7); break;
+	         case '\ue038': doType(mode,KeyEvent.VK_NUMPAD8); break;
+	         case '\ue039': doType(mode,KeyEvent.VK_NUMPAD9); break;
+	         case '\ue03A': doType(mode,KeyEvent.VK_SEPARATOR); break;
+	         case '\ue03B': doType(mode,KeyEvent.VK_NUM_LOCK); break;
+	         case '\ue03C': doType(mode,KeyEvent.VK_ADD); break;
+	         case '\ue03D': doType(mode,KeyEvent.VK_MINUS); break;
+	         case '\ue03E': doType(mode,KeyEvent.VK_MULTIPLY); break;
+	         case '\ue03F': doType(mode,KeyEvent.VK_DIVIDE); break;
+	         default:
+	            throw new IllegalArgumentException("Cannot type character " + character);
+	      }
+	   }
+
+	/**
+	 * Smooth moves the mouse
+	 */
+	@Override
+	public void smoothMove(Location dest) {
+		smoothMove(new Location(last_x,last_y),
+				dest, (long)(Settings.MoveMouseDelay*1000L));
+	}
+
+	/**
+	 * Uses the Animator class to smooth move the mouse
+	 */
+	@Override
+	public void smoothMove(Location src, Location dest, long ms) {
+		if(ms == 0){
+			mouseMove(dest.x, dest.y);
+	         return;
+		}
+		
+		AnimatorTimeBased aniX = new AnimatorTimeBased(
+	                        new AnimatorOutQuarticEase((float)src.x, (float)dest.x, ms));
+		AnimatorTimeBased aniY = new AnimatorTimeBased(
+	                        new AnimatorOutQuarticEase((float)src.y, (float)dest.y, ms));
+		while(aniX.running()){
+			float x = aniX.step();
+			float y = aniY.step();
+			mouseMove((int)x, (int)y);
+			delay(50);
+		}
+	}
+	
+	//Other functions//////////////////////////////////////////////////////////
+	
+	/**
+     * Helper function that converts from KeyEvent.VK_(key) to
+     * X11 Keysyms for use in RFB Protocol Messages.
+     * 
+     */
+    private int getKeysym(int keycode){
+        int key;
+        if(shiftFlag){
+        	switch(keycode){
+        	case (KeyEvent.VK_0): key=0x0029; break; //right paren
+            case (KeyEvent.VK_1): key=0x0021; break; //exclaimation
+            case (KeyEvent.VK_2): key=0x0040; break; //at sign
+            case (KeyEvent.VK_3): key=0x0023; break; //number sign
+            case (KeyEvent.VK_4): key=0x0024; break; //dollar
+            case (KeyEvent.VK_5): key=0x0025; break; //percent
+            case (KeyEvent.VK_6): key=0x005e; break; //circumflex
+            case (KeyEvent.VK_7): key=0x0026; break; //ampersand
+            case (KeyEvent.VK_8): key=0x002a; break; //asterisk
+            case (KeyEvent.VK_9): key=0x0028; break; //left paren
+            case (KeyEvent.VK_BACK_SPACE): key=0xff08; break; 
+            case (KeyEvent.VK_TAB): key=0xfd05; break; //back tab
+            case (KeyEvent.VK_ENTER): key=0xff0d; break;
+            case (KeyEvent.VK_INSERT): key=0xfd1d; break; //printscreen
+            case (KeyEvent.VK_DELETE): key=0xffff; break;
+            case (KeyEvent.VK_HOME): key=0xff50; break;
+            case (KeyEvent.VK_END): key=0xff57; break;
+            case (KeyEvent.VK_PAGE_UP): key=0xff55; break;
+            case (KeyEvent.VK_PAGE_DOWN): key=0xff56; break;
+            case (KeyEvent.VK_LEFT): key=0xff51; break;
+            case (KeyEvent.VK_UP): key=0xff52; break;
+            case (KeyEvent.VK_RIGHT): key=0xff53; break;
+            case (KeyEvent.VK_DOWN): key=0xff54; break;
+            case (KeyEvent.VK_F1): key=0xffbe; break;
+            case (KeyEvent.VK_F2): key=0xffbf; break;
+            case (KeyEvent.VK_F3): key=0xffc0; break;
+            case (KeyEvent.VK_F4): key=0xffc1; break;
+            case (KeyEvent.VK_F5): key=0xffc2; break;
+            case (KeyEvent.VK_F6): key=0xffc3; break;
+            case (KeyEvent.VK_F7): key=0xffc4; break;
+            case (KeyEvent.VK_F8): key=0xffc5; break;
+            case (KeyEvent.VK_F9): key=0xffc6; break;
+            case (KeyEvent.VK_F10): key=0xffc7; break;
+            case (KeyEvent.VK_F11): key=0xffc8; break;
+            case (KeyEvent.VK_F12): key=0xffc9; break;
+            case (KeyEvent.VK_CONTROL): key=0xffe3; break;
+            case (KeyEvent.VK_META): key=0xffe7; break;
+            case (KeyEvent.VK_ALT): key=0xffe9; break;
+            case (KeyEvent.VK_A): key=0x0041; break;//A
+            case (KeyEvent.VK_B): key=0x0042; break;//B
+            case (KeyEvent.VK_C): key=0x0043; break;//C
+            case (KeyEvent.VK_D): key=0x0044; break;//D
+            case (KeyEvent.VK_E): key=0x0045; break;//E
+            case (KeyEvent.VK_F): key=0x0046; break;//F
+            case (KeyEvent.VK_G): key=0x0047; break;//G
+            case (KeyEvent.VK_H): key=0x0048; break;//H
+            case (KeyEvent.VK_I): key=0x0049; break;//I
+            case (KeyEvent.VK_J): key=0x004a; break;//J
+            case (KeyEvent.VK_K): key=0x004b; break;//K
+            case (KeyEvent.VK_L): key=0x004c; break;//L
+            case (KeyEvent.VK_M): key=0x004d; break;//M
+            case (KeyEvent.VK_N): key=0x004e; break;//N
+            case (KeyEvent.VK_O): key=0x004f; break;//O
+            case (KeyEvent.VK_P): key=0x0050; break;//P
+            case (KeyEvent.VK_Q): key=0x0051; break;//Q
+            case (KeyEvent.VK_R): key=0x0052; break;//R
+            case (KeyEvent.VK_S): key=0x0053; break;//S
+            case (KeyEvent.VK_T): key=0x0054; break;//T
+            case (KeyEvent.VK_U): key=0x0055; break;//U
+            case (KeyEvent.VK_V): key=0x0056; break;//V
+            case (KeyEvent.VK_W): key=0x0057; break;//W
+            case (KeyEvent.VK_X): key=0x0058; break;//X
+            case (KeyEvent.VK_Y): key=0x0059; break;//Y
+            case (KeyEvent.VK_Z): key=0x005a; break;//Z
+            case (KeyEvent.VK_SPACE): key=0x0020; break;
+            case (KeyEvent.VK_BACK_QUOTE): key=0x007e; break; //~
+            case (KeyEvent.VK_MINUS): key=0x005f; break;//_
+            case (KeyEvent.VK_EQUALS): key=0x002b; break;//+
+            case (KeyEvent.VK_QUOTE): key=0x0022; break;//"
+            case (KeyEvent.VK_SEMICOLON): key=0x003a; break;//:
+            case (KeyEvent.VK_BACK_SLASH): key=0x007c; break;//|
+            case (KeyEvent.VK_BRACELEFT): key=0x007b; break;//{
+            case (KeyEvent.VK_BRACERIGHT): key=0x007d; break;//}
+            case (KeyEvent.VK_PERIOD): key=0x003e; break;//>
+            case (KeyEvent.VK_COMMA): key=0x003c; break;//<
+            case (KeyEvent.VK_SLASH): key=0x003f; break;//?
+            case (KeyEvent.VK_PLUS): key=0x002b; break;
+            case (KeyEvent.VK_OPEN_BRACKET): key=0x007b; break;//{
+            case (KeyEvent.VK_CLOSE_BRACKET): key=0x007d; break;//}
+            case (KeyEvent.VK_ESCAPE): key=0xff1b; break;
+            case (KeyEvent.VK_F13): key=0xffca; break;
+            case (KeyEvent.VK_F14): key=0xffcb; break;
+            case (KeyEvent.VK_F15): key=0xffcb; break;
+            case (KeyEvent.VK_PRINTSCREEN): key=0xfd1d; break;
+            case (KeyEvent.VK_SCROLL_LOCK): key=0xff14; break;
+            case (KeyEvent.VK_PAUSE): key=0xff13; break;
+            case (KeyEvent.VK_CAPS_LOCK): key=0xffe5; break;
+            case (KeyEvent.VK_NUMPAD0): key=0x0030; break;
+            case (KeyEvent.VK_NUMPAD1): key=0x0031; break;
+            case (KeyEvent.VK_NUMPAD2): key=0x0032; break;
+            case (KeyEvent.VK_NUMPAD3): key=0x0033; break;
+            case (KeyEvent.VK_NUMPAD4): key=0x0034; break;
+            case (KeyEvent.VK_NUMPAD5): key=0x0035; break;
+            case (KeyEvent.VK_NUMPAD6): key=0x0036; break;
+            case (KeyEvent.VK_NUMPAD7): key=0x0037; break;
+            case (KeyEvent.VK_NUMPAD8): key=0x0038; break;
+            case (KeyEvent.VK_NUMPAD9): key=0x0039; break;
+            case (KeyEvent.VK_SEPARATOR): key=0xffac; break;
+            case (KeyEvent.VK_NUM_LOCK): key=0xff7f; break;
+            case (KeyEvent.VK_MULTIPLY): key=0x002a; break;
+            case (KeyEvent.VK_ADD): key=0x002b; break;
+            case (KeyEvent.VK_DIVIDE): key=0x002f; break;
+            default: key=0xffffff; break;
+        	}
+        }
+        else{
+        	switch(keycode){
+            case (KeyEvent.VK_0): key=0x0030; break;//0
+            case (KeyEvent.VK_1): key=0x0031; break;//1
+            case (KeyEvent.VK_2): key=0x0032; break;//2
+            case (KeyEvent.VK_3): key=0x0033; break;//3
+            case (KeyEvent.VK_4): key=0x0034; break;//4
+            case (KeyEvent.VK_5): key=0x0035; break;//5
+            case (KeyEvent.VK_6): key=0x0036; break;//6
+            case (KeyEvent.VK_7): key=0x0037; break;//7
+            case (KeyEvent.VK_8): key=0x0038; break;//8
+            case (KeyEvent.VK_9): key=0x0039; break;//9
+            case (KeyEvent.VK_BACK_SPACE): key=0xff08; break;
+            case (KeyEvent.VK_TAB): key=0xff09; break;
+            case (KeyEvent.VK_ENTER): key=0xff0d; break;
+            case (KeyEvent.VK_INSERT): key=0xff63; break;
+            case (KeyEvent.VK_DELETE): key=0xffff; break;
+            case (KeyEvent.VK_HOME): key=0xff50; break;
+            case (KeyEvent.VK_END): key=0xff57; break;
+            case (KeyEvent.VK_PAGE_UP): key=0xff55; break;
+            case (KeyEvent.VK_PAGE_DOWN): key=0xff56; break;
+            case (KeyEvent.VK_LEFT): key=0xff51; break;
+            case (KeyEvent.VK_UP): key=0xff52; break;
+            case (KeyEvent.VK_RIGHT): key=0xff53; break;
+            case (KeyEvent.VK_DOWN): key=0xff54; break;
+            case (KeyEvent.VK_F1): key=0xffbe; break;
+            case (KeyEvent.VK_F2): key=0xffbf; break;
+            case (KeyEvent.VK_F3): key=0xffc0; break;
+            case (KeyEvent.VK_F4): key=0xffc1; break;
+            case (KeyEvent.VK_F5): key=0xffc2; break;
+            case (KeyEvent.VK_F6): key=0xffc3; break;
+            case (KeyEvent.VK_F7): key=0xffc4; break;
+            case (KeyEvent.VK_F8): key=0xffc5; break;
+            case (KeyEvent.VK_F9): key=0xffc6; break;
+            case (KeyEvent.VK_F10): key=0xffc7; break;
+            case (KeyEvent.VK_F11): key=0xffc8; break;
+            case (KeyEvent.VK_F12): key=0xffc9; break;
+            case (KeyEvent.VK_CONTROL): key=0xffe3; break;
+            case (KeyEvent.VK_META): key=0xffe7; break;
+            case (KeyEvent.VK_ALT): key=0xffe9; break;
+            case (KeyEvent.VK_A): key=0x0061; break;//a
+            case (KeyEvent.VK_B): key=0x0062; break;//b
+            case (KeyEvent.VK_C): key=0x0063; break;//c
+            case (KeyEvent.VK_D): key=0x0064; break;//d
+            case (KeyEvent.VK_E): key=0x0065; break;//e
+            case (KeyEvent.VK_F): key=0x0066; break;//f
+            case (KeyEvent.VK_G): key=0x0067; break;//g
+            case (KeyEvent.VK_H): key=0x0068; break;//h
+            case (KeyEvent.VK_I): key=0x0069; break;//i
+            case (KeyEvent.VK_J): key=0x006a; break;//j
+            case (KeyEvent.VK_K): key=0x006b; break;//k
+            case (KeyEvent.VK_L): key=0x006c; break;//l
+            case (KeyEvent.VK_M): key=0x006d; break;//m
+            case (KeyEvent.VK_N): key=0x006e; break;//n
+            case (KeyEvent.VK_O): key=0x006f; break;//o
+            case (KeyEvent.VK_P): key=0x0070; break;//p
+            case (KeyEvent.VK_Q): key=0x0071; break;//q
+            case (KeyEvent.VK_R): key=0x0072; break;//r
+            case (KeyEvent.VK_S): key=0x0073; break;//s
+            case (KeyEvent.VK_T): key=0x0074; break;//t
+            case (KeyEvent.VK_U): key=0x0075; break;//u
+            case (KeyEvent.VK_V): key=0x0076; break;//v
+            case (KeyEvent.VK_W): key=0x0077; break;//w
+            case (KeyEvent.VK_X): key=0x0078; break;//x
+            case (KeyEvent.VK_Y): key=0x0079; break;//y
+            case (KeyEvent.VK_Z): key=0x007a; break;//z
+            case (KeyEvent.VK_SPACE): key=0x0020; break;
+            case (KeyEvent.VK_BACK_QUOTE): key=0x0060; break;//`
+            case (KeyEvent.VK_MINUS): key=0x002d; break;//-
+            case (KeyEvent.VK_EQUALS): key=0x003d; break;//=
+            case (KeyEvent.VK_QUOTE): key=0x0027; break;//'
+            case (KeyEvent.VK_SEMICOLON): key=0x003b; break;//;
+            case (KeyEvent.VK_BACK_SLASH): key=0x005c; break;//\
+            case (KeyEvent.VK_BRACELEFT): key=0x005b; break;//{
+            case (KeyEvent.VK_BRACERIGHT): key=0x005d; break;//}
+            case (KeyEvent.VK_PERIOD): key=0x002e; break;//.
+            case (KeyEvent.VK_COMMA): key=0x002c; break;//,
+            case (KeyEvent.VK_SLASH): key=0x002f; break;///
+            case (KeyEvent.VK_PLUS): key=0x002b; break;//+
+            case (KeyEvent.VK_OPEN_BRACKET): key=0x005b; break;//[
+            case (KeyEvent.VK_CLOSE_BRACKET): key=0x005d; break;//]
+            case (KeyEvent.VK_ESCAPE): key=0xff1b; break;
+            case (KeyEvent.VK_F13): key=0xffca; break;
+            case (KeyEvent.VK_F14): key=0xffcb; break;
+            case (KeyEvent.VK_F15): key=0xffcb; break;
+            case (KeyEvent.VK_PRINTSCREEN): key=0xfd1d; break;
+            case (KeyEvent.VK_SCROLL_LOCK): key=0xff14; break;
+            case (KeyEvent.VK_PAUSE): key=0xff13; break;
+            case (KeyEvent.VK_CAPS_LOCK): key=0xffe5; break;
+            case (KeyEvent.VK_NUMPAD0): key=0x0030; break;//0
+            case (KeyEvent.VK_NUMPAD1): key=0x0031; break;//1
+            case (KeyEvent.VK_NUMPAD2): key=0x0032; break;//2
+            case (KeyEvent.VK_NUMPAD3): key=0x0033; break;//3
+            case (KeyEvent.VK_NUMPAD4): key=0x0034; break;//4
+            case (KeyEvent.VK_NUMPAD5): key=0x0035; break;//5
+            case (KeyEvent.VK_NUMPAD6): key=0x0036; break;//6
+            case (KeyEvent.VK_NUMPAD7): key=0x0037; break;//7
+            case (KeyEvent.VK_NUMPAD8): key=0x0038; break;//8
+            case (KeyEvent.VK_NUMPAD9): key=0x0039; break;//9
+            case (KeyEvent.VK_SEPARATOR): key=0xffac; break;
+            case (KeyEvent.VK_NUM_LOCK): key=0xff7f; break;
+            case (KeyEvent.VK_MULTIPLY): key=0x002a; break;
+            case (KeyEvent.VK_ADD): key=0x002b; break;
+            case (KeyEvent.VK_DIVIDE): key=0x002f; break;
+            default: key=0xffffff; break;
+        	}
+        }
+        //System.out.println("Keycode-"+keycode);
+        //System.out.println("Shiftflag-"+shiftFlag);
+        //System.out.println("Key-"+Integer.toHexString(key));
+        return key;
+    }
+    
+    /**
+     * Executes after Robot performs action
+     */
+    private void tidyUp(){
+    	if(waitForIdle){
+    		waitForIdle();
+    	}
+    	delay(autodelay);
+    }
+
+//NEW SIKULI METHODS
+    
+	@Override
+	public void keyDown(String keys) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void keyUp(String keys) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void keyUp() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void pressModifiers(int modifiers) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void releaseModifiers(int modifiers) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void typeKey(int key) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void typeStarts() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void typeEnds() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void clickStarts() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void clickEnds() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public Color getColorAt(int x, int y) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public void cleanup() {
+	}
+
+	@Override
+	public boolean isRemote() {
+		return true;
+	}
+
+	@Override
+	public IScreen getScreen() {
+		return null;
+	}
+}
diff --git a/API/src/main/java/edu/unh/iol/dlc/VNCScreen.java b/API/src/main/java/edu/unh/iol/dlc/VNCScreen.java
new file mode 100644
index 0000000..b227c1f
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/VNCScreen.java
@@ -0,0 +1,500 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.awt.AWTException;
+import java.awt.GraphicsDevice;
+import java.awt.Point;
+import java.awt.Rectangle;
+import org.sikuli.basics.Debug;
+import org.sikuli.basics.FileManager;
+import org.sikuli.basics.Settings;
+import org.sikuli.script.EventObserver;
+import org.sikuli.script.EventSubject;
+import org.sikuli.script.IRobot;
+import org.sikuli.script.IScreen;
+import org.sikuli.script.Location;
+import org.sikuli.script.Mouse;
+import org.sikuli.script.OverlayCapturePrompt;
+import org.sikuli.script.Region;
+import org.sikuli.script.ScreenHighlighter;
+import org.sikuli.script.ScreenImage;
+import org.sikuli.script.ScreenUnion;
+import org.sikuli.script.SikuliX;
+
+/**
+ * The VNCScreen is an implementation of IScreen that uses a VNCRobot to
+ * control the VNC connection.
+ */
+public class VNCScreen extends Region implements EventObserver, IScreen {
+	
+	private static String me = "VNCScreen";
+	private static int lvl = 3;
+	
+	private static void log(int level, String message, Object... args) {
+		Debug.logx(level, "", me + ": " + message, args);
+	}
+	
+	protected static int _primaryScreen = -1;
+	
+	protected static Framebuffer[] _gdev;
+	protected static Rectangle[] gdevsBounds;
+	protected static ConnectionController _genv = null;
+	protected static VNCScreen[] screens;
+	private static VNCRobot[] mouseRobot;
+	private static int waitForScreenshot = 300;
+	
+	protected Framebuffer _curGD;
+	protected int _curID = 0;
+	protected int oldID = 0;
+	protected IRobot robot = null;
+	protected boolean waitPrompt;
+	protected OverlayCapturePrompt prompt;
+	private ScreenImage lastScreenImage = null;
+	private String promptMsg = "Select a region on the screen";
+	
+//Screen Methods**************************************************************/	
+	
+	static{
+		FileManager.loadLibrary("VisionProxy");
+	    initScreens(false);
+	}
+	
+	private static void initScreens(boolean reset) {
+
+		log(lvl+1, "initScreens: entry");
+		if (_genv != null && !reset) {
+			return;
+		}
+		    
+		_genv = ConnectionController.getActiveController(0);
+		if(_genv == null){
+			Debug.error("Did not find any active ConnectionControllers.  " +
+					"Cannot use VNCScreen without a ConnectionController instance.");
+			SikuliX.endFatal(999);
+		}
+		_gdev = (Framebuffer[])_genv.getScreenDevices();
+		
+		gdevsBounds = new Rectangle[_gdev.length];
+		screens = new VNCScreen[_gdev.length];
+		
+		if (_gdev.length == 0) {
+			Debug.error("VNCScreen: initScreens: GraphicsEnvironment has no screens");
+			SikuliX.endFatal(999);
+		}
+
+		_primaryScreen = -1;
+
+		for (int i = 0; i < getNumberScreens(); i++) {
+			gdevsBounds[i] = _gdev[i].getDefaultConfiguration().getBounds();
+			
+			if (gdevsBounds[i].contains(new Point(0, 0))) {
+				if (_primaryScreen < 0) {
+					_primaryScreen = i;
+					log(lvl, "initScreens: ScreenDevice %d contains (0,0) --- will be used as primary", i);
+				} 
+				else {
+					log(lvl, "initScreens: ScreenDevice %d too contains (0,0)!", i);
+				}
+			}
+		}
+		
+		if (_primaryScreen < 0) {
+			Debug.log("Screen: initScreens: no ScreenDevice contains (0,0) --- using first ScreenDevice as primary");
+			_primaryScreen = 0;
+		}
+		
+		log(lvl+1, "initScreens: after GD evaluation");
+		for (int i = 0; i < screens.length; i++) {
+			screens[i] = new VNCScreen(i, true);
+			screens[i].initScreen();
+		}
+		try {
+			log(lvl+1, "initScreens: getting mouseRobot");
+			
+			mouseRobot = new VNCRobot[screens.length];
+			
+			for(int i = 0; i < screens.length; i++){
+				mouseRobot[i] = new VNCRobot(_gdev[i]);
+				mouseRobot[i].setAutoDelay(10);
+			}
+		} 
+		catch (AWTException e) {
+			Debug.error("Can't initialize global Robot for Mouse: " + e.getMessage());
+			SikuliX.endFatal(999);
+		}
+		
+		if (!reset) {
+			log(lvl - 1, "initScreens: basic initialization (%d VNCScreen(s) found)", _gdev.length);
+			log(lvl, "*** monitor configuration (primary: %d) ***", _primaryScreen);
+			for (int i = 0; i < _gdev.length; i++) {
+				log(lvl, "%d: %s", i, screens[i].toStringShort());
+			}
+			log(lvl, "*** end monitor configuration ***");
+		}
+		
+		if (getNumberScreens() > 1) {
+			log(lvl, "initScreens: multi monitor mouse check");
+			Location lnow = Mouse.at();
+			float mmd = Settings.MoveMouseDelay;
+			Settings.MoveMouseDelay = 0f;
+			Location lc = null, lcn = null;
+			for (VNCScreen s : screens) {
+				lc = s.getCenter();
+				Mouse.move(lc);
+				lcn = Mouse.at();
+				if (!lc.equals(lcn)) {
+					log(lvl, "*** multimonitor click check: %s center: (%d, %d) --- NOT OK:  (%d, %d)",
+							s.toStringShort(), lc.x, lc.y, lcn.x, lcn.y);
+				} 
+				else {
+					log(lvl, "*** checking: %s center: (%d, %d) --- OK", s.toStringShort(), lc.x, lc.y);
+				}
+			}
+			Mouse.move(lnow);
+			Settings.MoveMouseDelay = mmd;
+		}
+	}
+	
+	protected static VNCRobot getMouseRobot(){
+		return mouseRobot[0];
+	}
+	
+	public static ScreenUnion all() {
+		return new ScreenUnion();
+	}
+	
+	public static int getNumberScreens(){
+	    return _gdev.length;
+	}
+	
+	private static int getValidID(int id) {
+		if (id < 0 || id >= _gdev.length) {
+			Debug.error("VNCScreen: invalid screen id %d - using primary screen", id);
+			return _primaryScreen;
+		}
+		return id;
+	}
+
+	public static int getPrimaryId() {
+		return _primaryScreen;
+	}
+
+	
+	public static VNCScreen getPrimaryScreen() {
+		return screens[_primaryScreen];
+	}
+
+	
+	public static VNCScreen getScreen(int id) {
+		return screens[getValidID(id)];
+	}
+
+	public static Rectangle getBounds(int id) {
+		return gdevsBounds[getValidID(id)];
+	}
+
+	public static IRobot getRobot(int id) {
+		return getScreen(id).getRobot();
+	}
+	
+	public static void showMonitors() {
+		Debug.info("*** monitor configuration [ %s VNCScreen(s)] ***", VNCScreen.getNumberScreens());
+		Debug.info("*** Primary is VNCScreen %d", _primaryScreen);
+		for (int i = 0; i < _gdev.length; i++) {
+			Debug.info("Screen %d: %s", i, VNCScreen.getScreen(i).toStringShort());
+		}
+		Debug.info("*** end monitor configuration ***");
+	}
+
+	public static void resetMonitors() {
+	    Debug.error("*** BE AWARE: experimental - might not work ***");
+	    Debug.error("Re-evaluation of the monitor setup has been requested");
+	    Debug.error("... Current Region/Screen objects might not be valid any longer");
+	    Debug.error("... Use existing Region/Screen objects only if you know what you are doing!");
+	    initScreens(true);
+	    Debug.info("*** new monitor configuration [ %s Screen(s)] ***", VNCScreen.getNumberScreens());
+	    Debug.info("*** Primary is VNCScreen %d", _primaryScreen);
+	    for (int i = 0; i < _gdev.length; i++) {
+	      Debug.info("VNCScreen %d: %s", i, VNCScreen.getScreen(i).toStringShort());
+	    }
+	    Debug.error("*** end new monitor configuration ***");
+	}
+	
+	public VNCScreen() {
+		super();
+		_curID = _primaryScreen;
+		initScreen();
+		super.initScreen(this);
+	}
+	
+	public VNCScreen(int id){
+		super();
+	    if(id < 0 || id >= _gdev.length) {
+	    	throw new IllegalArgumentException("VNCScreen ID " + id + " not in valid range " +
+	    			"(between 0 and " + (_gdev.length - 1));
+	    }
+	    _curID = id;
+	    initScreen();
+		super.initScreen(this);
+	}
+	
+	public VNCScreen(int id, boolean b) {
+		super();
+		_curID = id;
+		initScreen();
+		super.initScreen(this);
+	}
+	
+	public VNCScreen(boolean isScreenUnion) {
+		super();
+		initScreen();
+		super.initScreen(this);
+	}
+	
+	private void initScreen() {
+		setOtherScreen();
+		_curGD = _gdev[_curID];
+		Rectangle bounds = getBounds();
+			x = (int) bounds.getX();
+			y = (int) bounds.getY();
+			w = (int) bounds.getWidth();
+			h = (int) bounds.getHeight();
+			
+		try {
+			robot = new VNCRobot(_curGD);
+			robot.setAutoDelay(10);
+		} 
+		catch (AWTException e) {
+			Debug.error("Can't initialize Java Robot on VNCScreen " + _curID + ": " + e.getMessage());
+			robot = null;
+		}
+	}
+	
+	public void setAsScreenUnion() {
+		oldID = _curID;
+		_curID = -1;
+	}
+	
+	public void setAsScreen() {
+		_curID = oldID;
+	}
+	
+	@Override
+	public void initScreen(IScreen scr){
+		updateSelf();
+	}
+	
+	@Override
+	public IScreen getScreen(){
+		return this;
+	}
+	
+	
+	@Override
+	protected Region setScreen(IScreen s) {
+		throw new UnsupportedOperationException("The setScreen() method cannot be called from a VNCScreen object.");
+	}
+
+	protected boolean useFullscreen() {
+		return false;
+	}
+	
+	@Override
+	public int getID() {
+		return _curID;
+	}
+
+	@Override
+	public int getIdFromPoint(int x, int y) {
+		return _curID;
+	}
+
+	public GraphicsDevice getGraphicsDevice() {
+		return _curGD;
+	}
+
+	@Override
+	public IRobot getRobot() {
+		return robot;
+	}
+
+	@Override
+	public Rectangle getBounds() {
+		return gdevsBounds[_curID];
+	}
+	
+	public Region newRegion(Location loc, int width, int height) {
+		//return Region.create(loc.copyTo(this), width, height);
+		return new Region(loc.x, loc.y, width, height, loc.getScreen());
+	}
+
+	@Override
+	public ScreenImage getLastScreenImageFromScreen() {
+		return lastScreenImage;
+	}
+	
+	public Location newLocation(Location loc) {
+		return loc.setOtherScreen(this);
+	}
+
+	@Override
+	public ScreenImage capture() {
+		return capture(getRect());
+	}
+	
+	@Override
+	public ScreenImage capture(int x, int y, int w, int h) {
+		Rectangle rect = newRegion(new Location(x, y), w, h).getRect();
+		return capture(rect);
+	}
+
+	@Override
+	public ScreenImage capture(Rectangle rect) {
+		log(lvl + 1, "VNCScreen.capture: (%d,%d) %dx%d", rect.x, rect.y, rect.width, rect.height);
+		ScreenImage simg = robot.captureScreen(rect);
+		lastScreenImage = simg;
+		return simg;
+	}
+
+	@Override
+	public ScreenImage capture(Region reg) {
+		return capture(reg.getRect());
+	}
+	
+	public ScreenImage userCapture() {
+		return userCapture(promptMsg);
+	}
+	
+	@Override
+	public ScreenImage userCapture(final String msg) {
+		waitPrompt = true;
+		Thread th = new Thread() {
+			
+			@Override
+			public void run() {
+				if ("".equals(msg)) {
+					prompt = new OverlayCapturePrompt(null, VNCScreen.this);
+					prompt.prompt(promptMsg);
+				} 
+				else {
+					prompt = new OverlayCapturePrompt(VNCScreen.this, VNCScreen.this);
+					prompt.prompt(msg);
+				}
+			}
+		};
+		
+		th.start();
+		
+		try {
+			int count = 0;
+			while (waitPrompt) {
+				Thread.sleep(100);
+				if (count++ > waitForScreenshot) {
+					return null;
+				}
+			}
+		} 
+		catch (InterruptedException e) {
+			e.printStackTrace();
+		}
+		
+		ScreenImage ret = prompt.getSelection();
+		lastScreenImage = ret;
+		prompt.close();
+		return ret;
+	}
+	
+	public Region selectRegion() {
+		return selectRegion("Select a region on the screen");
+	}
+	
+	public Region selectRegion(final String msg) {
+		ScreenImage sim = userCapture(msg);
+		if (sim == null) {
+			return null;
+		}
+		Rectangle r = sim.getROI();
+		return Region.create((int) r.getX(), (int) r.getY(),
+				(int) r.getWidth(), (int) r.getHeight());
+	}
+	
+	@Override
+	public void update(EventSubject s) {
+		waitPrompt = false;
+	}
+	
+	@Override
+	public void showTarget(Location loc) {
+		showTarget(loc, Settings.SlowMotionDelay);
+	}
+	
+	protected void showTarget(Location loc, double secs) {
+		if (Settings.isShowActions()) {
+			ScreenHighlighter overlay = new ScreenHighlighter(this, null);
+			overlay.showTarget(loc, (float) secs);
+		}
+	}
+	
+	@Override
+	public boolean isOtherScreen(){
+		return otherScreen;
+	}
+	
+	@Override
+	public Rectangle getRect(){
+		return new Rectangle(x, y, w, h);
+	}
+	
+	@Override
+	public int getX(){
+		return (int) getBounds().getX();
+	}
+	
+	@Override
+	public int getY(){
+		return (int) getBounds().getY();
+	}
+	
+	@Override
+	public int getW(){
+		return (int) getBounds().getWidth();
+	}
+	
+	@Override
+	public int getH(){
+		return (int) getBounds().getHeight();
+	}
+	
+	@Override
+	public String toString() {
+		Rectangle r = getBounds();
+		return String.format("S(%d)[%d,%d %dx%d] E:%s, T:%.1f",
+				_curID, (int) r.getX(), (int) r.getY(),
+				(int) r.getWidth(), (int) r.getHeight(),
+				getThrowException() ? "Y" : "N", getAutoWaitTimeout());
+	}
+	
+	@Override
+	public String toStringShort(){
+		Rectangle r = getBounds();
+	    return String.format("S(%d)[%d,%d %dx%d]",
+	            _curID, (int) r.getX(), (int) r.getY(),
+	            (int) r.getWidth(), (int) r.getHeight());
+	}
+}
diff --git a/API/src/main/java/edu/unh/iol/dlc/VNCThread.java b/API/src/main/java/edu/unh/iol/dlc/VNCThread.java
new file mode 100644
index 0000000..97e71eb
--- /dev/null
+++ b/API/src/main/java/edu/unh/iol/dlc/VNCThread.java
@@ -0,0 +1,313 @@
+/*
+ *                       University of New Hampshire
+ *                       InterOperability Laboratory
+ *                           Copyright (c) 2014
+ *
+ * This software is provided by the IOL ``AS IS'' and any express or implied
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose are disclaimed.
+ * In no event shall the InterOperability Lab be liable for any direct,
+ * indirect, incidental, special, exemplary, or consequential damages.
+ *
+ * This software may not be resold without the express permission of
+ * the InterOperability Lab.
+ *
+ * Feedback on this code may be sent to Mike Johnson (mjohnson@iol.unh.edu)
+ * and dlnalab@iol.unh.edu.
+ */
+package edu.unh.iol.dlc;
+
+import java.io.IOException;
+import java.net.Socket;
+
+/**
+ * The VNC thread object handles connecting to the server and keeping the
+ * framebuffer up to date by polling the server for changes.
+ * 
+ * @author Mike Johnson
+ */
+public class VNCThread extends Thread{
+	
+	//keep the connection open or not
+	private boolean listen = true;
+	
+	//interval to poll VNC server for changes (milliseconds)
+	private int pollInterval = 50; 
+	
+	//protocol message object
+	private VNCClient client;
+	//local copy of remote framebuffer
+	private Framebuffer screen;
+	
+	//flag of whether the connection is configured correctly based on what
+	//the VNC stack currectly supports
+	private boolean pixel_flag = false;
+	
+	private boolean connected = false;
+	
+	public VNCThread(Socket s){
+		client = new VNCClient(s);
+		screen = new Framebuffer();
+	}
+	
+    /**
+     * terminates the thread
+     */
+	public void terminate(){
+    	listen = false;
+    }
+	
+    public VNCClient getClient(){
+    	return client;
+    }
+    
+    public Framebuffer getScreen(){
+    	return screen;
+    }
+    
+    /**
+     * Changes the interval at which the VNC Client
+     * polls the server for updates.
+     * 
+     * @param milliseconds
+     */
+    public void changePollInterval(int milliseconds){
+    	pollInterval = milliseconds;
+    }
+    
+    /**
+     * This method connects the client to the server and invokes the necessary
+     * methods so that the user does not need to worry about the underlying VNC
+     * messages.
+     *
+     * @param connectOthers 1  The client will share the connection with others
+     *                      0  The client will not share the connection
+     * @param securityType  0 Invalid
+     *                      1 None
+     *                      2 VNC Authentication
+     */
+    public void openConnection(int connectOthers, int securityType){
+    	
+    	try{
+    		client.protocolHandshake();
+    		client.securityMethod(client.securityInit(securityType));
+    		client.clientInit(connectOthers);
+    		int[] firstInput = client.listenServerInit();
+    		String secondInput = client.readDesktopName();
+    		pixel_flag = screen.setPF(firstInput, secondInput);
+    		connected = true;
+    	}
+    	catch(IOException e){
+    		System.err.println(e);
+    	}
+    	catch(InterruptedException ie){
+    		System.err.println(ie);
+    	}
+    }
+    
+    /**
+     * The SetPixelFormat method sets the format of the raw pixel data sent
+     * across the network by the VNC Server.
+     *
+     *@param the index in the array of the VNCClient
+     * @param format Can be either "Truecolor" or "Colormap"
+     * @param bits The number of bits per pixel
+     * @param bef The BigEndianFlag (0 is little endian)
+     * @throws IOException Thrown if there is a socket error.
+     */
+    public void setPixelFormat(String format, int bits, int bef) 
+    		throws IOException{
+    	
+        if(format.equals("Truecolor")){
+        	
+//        	System.out.println("Format: "+format);
+//        	System.out.println("Bits: "+bits);
+        	
+            switch(bits){
+                case 8:
+                	int[] a = {8,8,bef,1,7,7,3,5,2,0};
+                	client.setPixelFormat(a[0],a[1],a[2],a[3],a[4],
+                			a[5],a[6],a[7],a[8],a[9]);
+                    screen.resetPF(a);
+                    pixel_flag = true;
+                    break;
+                case 16:
+                	int[] b = {16,15,bef,1,31,31,31,10,5,0};
+                	client.setPixelFormat(b[0],b[1],b[2],b[3],b[4],
+                			b[5],b[6],b[7],b[8],b[9]);
+                    screen.resetPF(b);
+                	pixel_flag = true;
+                    break;
+                case 32:
+                	int[] c = {32,24,bef,1,255,255,255,16,8,0};
+                	client.setPixelFormat(c[0],c[1],c[2],c[3],c[4],
+                			c[5],c[6],c[7],c[8],c[9]);
+                    screen.resetPF(c);
+                	pixel_flag = false;
+                    break;
+                default:
+                    System.err.println("Error: Number of Bits unsupported");
+                    pixel_flag = true;
+                    break;
+            }
+        }
+        else if(format.equals("Colormap")){
+            switch(bits){
+                case 8:
+                	int[] a = {8,8,bef,1,7,7,3,5,2,0};
+                	client.setPixelFormat(a[0],a[1],a[2],a[3],a[4],
+                			a[5],a[6],a[7],a[8],a[9]);
+                    screen.resetPF(a);
+                	pixel_flag = true;
+                    break;
+                case 16:
+                	int[] b = {8,8,bef,1,7,7,3,5,2,0};
+                	client.setPixelFormat(b[0],b[1],b[2],b[3],b[4],
+                			b[5],b[6],b[7],b[8],b[9]);
+                    screen.resetPF(b);
+                	pixel_flag = true;
+                    break;
+                case 32:
+                	int[] c = {8,8,bef,1,7,7,3,5,2,0};
+                	client.setPixelFormat(c[0],c[1],c[2],c[3],c[4],
+                			c[5],c[6],c[7],c[8],c[9]);
+                    screen.resetPF(c);
+                	pixel_flag = true;
+                    break;
+                default:
+                    System.err.println("Error: Number of Bits unsupported");
+                    pixel_flag = true;
+                    break;
+            }
+        }
+        else{
+            System.err.println("Error: Format not supported.");
+            pixel_flag = true;
+        }
+    }
+	
+    @Override
+    public void run(){
+    	
+    	//if not connected sleep until it is
+    	while(!connected){
+    		try {
+				Thread.sleep(100);
+			} 
+    		catch (InterruptedException e) {
+    			System.err.println("Error: Thread Interrupted");
+			}
+    	}
+    	
+        try{
+        	client.framebufferUpdateRequest( //non-incremental update request
+                    pixel_flag,0, (short)0, (short)0,
+                    (short)screen.getWidth(), (short)screen.getHeight());
+        	
+            while (listen){
+            	if(client.available()){
+            		int message = client.readByte();
+                    switch (message){
+                        case 0:
+                          	client.readByte(); //padding
+                          	listenRemoteFramebufferUpdate();
+                            break;
+                        case 1:
+                            //client.listenSetColorMap();
+                            break;
+                        case 2:
+                          	//listenBell();
+                            break;
+                        case 3:
+                         	//client.listenServerCutText();
+                            break;
+                        default:
+                            System.err.println("Error: Unsupported " +
+                            		"Message Type: "+message);
+                            break;
+                    }
+            	}
+              	Thread.sleep(pollInterval);
+              	
+                client.framebufferUpdateRequest( //incremental update request
+                        pixel_flag,1, (short)0, (short)0,
+                        (short)screen.getWidth(), (short)screen.getHeight());
+            }
+            client.close();
+        }
+        catch(IOException io){
+        	System.err.println("Error: IO Exception"+io);
+        }
+        catch (InterruptedException e) {
+			System.err.println("Error: Thread Interrupted");
+		}
+    }
+    
+    /**
+     * Listens to the framebuffer update messages from the server
+     * 
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    private void listenRemoteFramebufferUpdate() 
+    		throws IOException, InterruptedException{
+    	
+    	int numRect,x,y,w,h,encType;
+    	
+        numRect = client.readShort();
+        
+        for(int i = 0; i < numRect; i++){
+        	x = client.readShort();
+            y = client.readShort();
+            w = client.readShort();
+            h = client.readShort();
+            encType = client.readInt();
+            switch(encType){
+            	case 0://raw encoding
+                    int[] pixels = client.readTC32Data(w*h*3);
+                    screen.raw(x, y, w, h, pixels);
+                    break;
+            	case 1://copy rect encoding
+            		int srcX = client.readShort();
+            		int srcY = client.readShort();
+            		screen.copyRect(x,y,w,h,srcX,srcY);
+            		break;
+            	default:
+            		System.err.println("Error: Encoding type not recognized " +
+            				"or supported: "+Integer.toString(encType));
+            		break;
+            }
+        }
+        screen.convertToBufferedImage();
+    }
+    
+/*Unimplemented Methods------------------------------------------------------*/
+    
+    /*
+    private void listenBell(){
+        System.out.println("Ring");
+    }
+    
+    private void listenSetColorMap()throws IOException{
+        dataIn.readUnsignedByte();
+        int first=dataIn.readUnsignedShort();
+        int num = dataIn.readUnsignedShort();
+        System.out.println(first+" first");
+        System.out.println(num+" num");
+        for(int i=0;i<num;i++){
+            int r = dataIn.readUnsignedShort();
+            int g = dataIn.readUnsignedShort();
+            int b = dataIn.readUnsignedShort();
+        }
+    }
+    
+    private String listenServerCutText() throws IOException{
+        dataIn.readUnsignedByte();
+        dataIn.readUnsignedByte(); //padding
+        dataIn.readUnsignedByte();
+        int length = dataIn.readInt();
+        byte[] b = new byte[length];
+        dataIn.read(b);
+        return new String(b, "ISO-8859-1");
+    }*/
+}
diff --git a/API/src/main/java/org/sikuli/script/Finder.java b/API/src/main/java/org/sikuli/script/Finder.java
old mode 100755
new mode 100644
index 631e777..efa5e83
--- a/API/src/main/java/org/sikuli/script/Finder.java
+++ b/API/src/main/java/org/sikuli/script/Finder.java
@@ -357,41 +357,41 @@
    *
    * @return true if Finder has a next match, false otherwise
    */
   @Override
   public boolean hasNext() {
     if (_results != null && _results.size() > _cur_result_i) {
       return true;
     }
     return false;
   }
 
   /**
    *
    * @return the next match or null
    */
   @Override
   public Match next() {
     Match ret = null;
     if (hasNext()) {
       FindResult fr = _results.get(_cur_result_i++);
-      Screen parentScreen = null;
+      IScreen parentScreen = null;
       if (_region != null) {
         parentScreen = _region.getScreen();
       }
       ret = new Match(fr, parentScreen);
 			fr.delete();
       if (_region != null) {
         ret = _region.toGlobalCoord(ret);
       }
       if (_pattern != null) {
         Location offset = _pattern.getTargetOffset();
         ret.setTargetOffset(offset);
       }
     }
     return ret;
   }
 
   /**
    * not used
    */
   @Override
diff --git a/API/src/main/java/org/sikuli/script/IScreen.java b/API/src/main/java/org/sikuli/script/IScreen.java
old mode 100755
new mode 100644
index 8e08585..4d26ac3
--- a/API/src/main/java/org/sikuli/script/IScreen.java
+++ b/API/src/main/java/org/sikuli/script/IScreen.java
@@ -8,21 +8,45 @@
 
 import java.awt.Rectangle;
 
 /**
  * INTERNAL USE
  * function template for (alternative) Screen implementations
  */
 public interface IScreen {
 
 	public IRobot getRobot();
 
 	public Rectangle getBounds();
 
 	public ScreenImage capture();
 
 	public ScreenImage capture(int x, int y, int w, int h);
 
 	public ScreenImage capture(Rectangle rect);
 
 	public ScreenImage capture(Region reg);
+
+	public boolean isOtherScreen();
+
+	public Rectangle getRect();
+
+	public void showTarget(Location location);
+
+	public int getID();
+
+	public ScreenImage getLastScreenImageFromScreen();
+
+	public int getX();
+
+	public int getW();
+
+	public int getY();
+	
+	public int getH();
+
+	public ScreenImage userCapture(String string);
+
+	public int getIdFromPoint(int srcx, int srcy);
+	
+	public String toStringShort();
 }
diff --git a/API/src/main/java/org/sikuli/script/ImageFinder.java b/API/src/main/java/org/sikuli/script/ImageFinder.java
index 093868b..7d60479 100644
--- a/API/src/main/java/org/sikuli/script/ImageFinder.java
+++ b/API/src/main/java/org/sikuli/script/ImageFinder.java
@@ -18,77 +18,77 @@
 import org.sikuli.basics.Debug;
 import org.sikuli.basics.Settings;
 
 /**
  * UNDER DEVELOPMENT --- SURELY HAS BUGS ;-)
  * Intended replacement for Finder together with ImageFind
  * completely implementing the OpenCV usage on the Java level.
  */
 public class ImageFinder extends Finder {
 
   private static String me = "ImageFinder";
   private static int lvl = 3;
 
   private static void log(int level, String message, Object... args) {
     Debug.logx(level, "", me + ": " + message, args);
   }
   private boolean isImageFinder = true;
   protected boolean isImage = false;
   protected Region region = null;
   protected boolean isRegion = false;
-  protected Screen screen = null;
+  protected IScreen screen = null;
   protected boolean isScreen = false;
   protected int offX, offY;
   protected long MaxTimePerScan;
   private Image bImage = null;
   protected Mat base = new Mat();
   private double waitingTime = Settings.AutoWaitTimeout;
   private int minChanges;
   private ImageFind firstFind = null;
   private boolean isReusable = false;
   protected boolean isMultiFinder = false;
 
   public ImageFinder() {
     init(null, null, null);
   }
 
   public ImageFinder(Image base) {
     init(base, null, null);
   }
 
-  public ImageFinder(Screen scr) {
+  public ImageFinder(IScreen scr) {
     init(null, scr, null);
   }
 
   public ImageFinder(Region reg) {
     init(null, null, reg);
   }
 
   protected ImageFinder(Mat base) {
     log(3, "init");
     reset();
     this.base = base;
     isImage = true;
     log(3, "search in: \n%s", base);
   }
 
-  private void init(Image base, Screen scr, Region reg) {
+  private void init(Image base, IScreen scr, Region reg) {
     log(3, "init");
     if (base != null) {
       setImage(base);
     } else if (scr != null) {
       setScreen(scr);
     } else if (reg != null) {
       setRegion(reg);
     }
   }
 
   private void reset() {
     firstFind = null;
     isImage = false;
     isScreen = false;
     isRegion = false;
     screen = null;
     region = null;
     bImage = null;
     base = new Mat();
   }
@@ -106,41 +106,41 @@
   public boolean setImage(Image base) {
     reset();
     if (base.isValid()) {
       bImage = base;
       this.base = Image.createMat(base.get());
       isImage = true;
       log(3, "search in: \n%s", base.get());
     }
     return isImage;
   }
 
   public boolean isImage() {
     return isImage;
   }
 
   protected void setBase(BufferedImage bImg) {
     log(3, "search in: \n%s", bImg);
     base = Image.createMat(bImg);
   }
 
-  public boolean setScreen(Screen scr) {
+  public boolean setScreen(IScreen scr) {
     reset();
     if (scr != null) {
       screen = scr;
       isScreen = true;
       setScreenOrRegion(scr);
     }
     return isScreen;
   }
 
   public boolean setRegion(Region reg) {
     reset();
     if (reg != null) {
       region = reg;
       isRegion = true;
       setScreenOrRegion(reg);
     }
     return isRegion;
   }
 
   private void setScreenOrRegion(Object reg) {
diff --git a/API/src/main/java/org/sikuli/script/Location.java b/API/src/main/java/org/sikuli/script/Location.java
old mode 100755
new mode 100644
index a0b156d..01b845b
--- a/API/src/main/java/org/sikuli/script/Location.java
+++ b/API/src/main/java/org/sikuli/script/Location.java
@@ -4,41 +4,41 @@
  *
  * modified RaiMan
  */
 package org.sikuli.script;
 
 import org.sikuli.basics.Debug;
 import java.awt.Color;
 import java.awt.Point;
 import java.awt.Rectangle;
 
 /**
  * A point like AWT.Point using global coordinates (x, y).
  * hence modifications might move location out of
  * any screen (not checked as is done with region)
  *
  */
 public class Location implements Comparable<Location>{
 
   public int x;
   public int y;
-  private Screen otherScreen = null;
+  private IScreen otherScreen = null;
 
   /**
    * to allow calculated x and y that might not be integers
    * @param x
    * @param y
    * truncated to the integer part
    */
   public Location(double x, double y) {
     this.x = (int) x;
     this.y = (int) y;
   }
 
   /**
    * a new point at the given coordinates
    * @param x
    * @param y
    */
   public Location(int x, int y) {
     this.x = x;
     this.y = y;
@@ -102,70 +102,70 @@
   }
 
   /**
    * sets the coordinates to the given values (moves it)
    * @param x might be non-int
    * @param y might be non-int
    * @return self/this
    */
   public Location setLocation(double x, double y) {
     this.x = (int) x;
     this.y = (int) y;
     return this;
   }
 
   /**
     * Returns null, if outside of any screen and not contained in a non-Desktop Screen instance (e.g. remote screen)<br>
     * subsequent actions WILL crash if not tested for null return
     *
     * @return the screen, that contains the given point
     */
-  public Screen getScreen() {
+  public IScreen getScreen() {
     Rectangle r;
     if (otherScreen != null) {
       return otherScreen;
     }
     for (int i = 0; i < Screen.getNumberScreens(); i++) {
       r = Screen.getScreen(i).getBounds();
       if (r.contains(this.x, this.y)) {
         return Screen.getScreen(i);
       }
     }
     Debug.error("Location: outside any screen (%s, %s) - subsequent actions might not work as expected", x, y);
     return null;
   }
 
 	/**
 	 * INTERNAL USE
 	 * reveals wether the containing screen is a DeskTopScreen or not
 	 * @return null if DeskTopScreen
 	 */
 	public boolean isOtherScreen() {
     return (otherScreen != null);
   }
 
 	/**
 	 * INTERNAL USE
 	 * identifies the point as being on a non-desktop-screen
 	 * @return this
 	 */
-  public Location setOtherScreen(Screen scr) {
+  public Location setOtherScreen(IScreen scr) {
     otherScreen = scr;
     return this;
   }
 
 	/**
 	 * INTERNAL USE
 	 * identifies the point as being on a non-desktop-screen
 	 * if this is true for the given location
 	 * @return this
 	 */
   private Location setOtherScreen(Location loc) {
     if (loc.isOtherScreen()) {
       setOtherScreen(loc.getScreen());
     }
     return this;
   }
 
 // TODO Location.getColor() implement more support and make it useable
   /**
    * Get the color at the given Point for details: see java.awt.Robot and ...Color
@@ -338,42 +338,42 @@
   public Location below(int dy) {
     return new Location(x, y + dy).setOtherScreen(this);
   }
 
   /**
    * new point with same offset to current screen's top left on given screen
    *
    * @param scrID number of screen
    * @return new location
    */
   public Location copyTo(int scrID) {
     return copyTo(Screen.getScreen(scrID));
   }
 
   /**
    * New point with same offset to current screen's top left on given screen
    *
    * @param screen new parent screen
    * @return new location
    */
-  public Location copyTo(Screen screen) {
-    Screen s = getScreen();
+  public Location copyTo(IScreen screen) {
+    IScreen s = getScreen();
     s = (s == null ? Screen.getPrimaryScreen() : s);
     Location o = new Location(s.getBounds().getLocation());
     Location n = new Location(screen.getBounds().getLocation());
     return new Location(n.x + x - o.x, n.y + y - o.y);
   }
 
   /**
    * Move the mouse to this location point
    *
    * @return this
    */
   public Location hover() {
     Mouse.move(this);
     return this;
   }
 
   /**
    * Move the mouse to this location point and click left
    *
    * @return this
@@ -424,45 +424,52 @@
   public int compareTo(Location loc) {
     if (equals(loc)) {
       return 0;
     }
     if (loc.x > x) {
       return 1;
     } else if (loc.x == x) {
       if (loc.y > y) {
         return 1;
       }
     }
     return -1;
   }
 
   /**
    * {@inheritDoc}
    * @return the description
    */
   @Override
   public String toString() {
-    Screen s = getScreen();
-    return "L(" + x + "," + y + ")" +
-            ((s == null) ? "" : "@" + s.toStringShort());
+    IScreen s = getScreen();
+    
+    if(s instanceof Screen){
+    	return "L(" + x + "," + y + ")" +
+                ((s == null) ? "" : "@" + ((Screen) s).toStringShort());
+    }
+    else{
+    	return "L(" + x + "," + y + ")" +
+                ((s == null) ? "" : "@" + s.toString());
+    }
   }
 
   /**
    *
    * @return a shorter description
    */
   public String toStringShort() {
     return "L(" + x + "," + y + ")";
   }
 
   // to avoid NPE for points outside any screen
   protected IRobot getRobotForPoint(String action) {
-    if (getScreen() == null) {
+	if (getScreen() == null) {
       Debug.error("Point %s outside any screen not useable for %s", this, action);
       return null;
     }
     if (!getScreen().isOtherScreen()) {
-      getScreen().showTarget(this);
+    	getScreen().showTarget(this);
     }
     return getScreen().getRobot();
   }
 }
diff --git a/API/src/main/java/org/sikuli/script/Match.java b/API/src/main/java/org/sikuli/script/Match.java
old mode 100755
new mode 100644
index 2ef7bbb..9a6dd22
--- a/API/src/main/java/org/sikuli/script/Match.java
+++ b/API/src/main/java/org/sikuli/script/Match.java
@@ -36,79 +36,79 @@
     lastFindTime = ftime;
     lastSearchTime = stime;
   }
 
   /**
    * create a copy of Match object<br>
    * to e.g. set another TargetOffset for same match
    *
    * @param m
    */
   public Match(Match m) {
     init(m.x, m.y, m.w, m.h, m.getScreen());
     copy(m);
   }
 
   public Match(Region reg, double sc) {
     init(reg.x, reg.y, reg.w, reg.h, reg.getScreen());
     simScore = sc;
   }
 
-  private Match(Match m, Screen parent) {
+  private Match(Match m, IScreen parent) {
     init(m.x, m.y, m.w, m.h, parent);
     copy(m);
   }
 
   /**
    * internally used constructor by TextRecognizer.listText()
    *
    * @param x
    * @param y
    * @param w
    * @param h
    * @param Score
    * @param parent
    * @param text
    */
-  protected Match(int x, int y, int w, int h, double Score, Screen parent, String text) {
+  protected Match(int x, int y, int w, int h, double Score, IScreen parent, String text) {
     init(x, y, w, h, parent);
     simScore = Score;
     ocrText = text;
   }
 
-  private Match(int _x, int _y, int _w, int _h, double score, Screen _parent) {
+  private Match(int _x, int _y, int _w, int _h, double score, IScreen _parent) {
     init(_x, _y, _w, _h, _parent);
     simScore = score;
   }
 
   /**
    * internally used constructor used by findX image
    *
    * @param f
    * @param _parent
    */
-  protected Match(FindResult f, Screen _parent) {
+  protected Match(FindResult f, IScreen _parent) {
     init(f.getX(), f.getY(), f.getW(), f.getH(), _parent);
     simScore = f.getScore();
   }
 
-  private void init(int X, int Y, int W, int H, Screen parent) {
+  private void init(int X, int Y, int W, int H, IScreen parent) {
     x = X;
     y = Y;
     w = W;
     h = H;
     setScreen(parent);
   }
 
   private void copy(Match m) {
     simScore = m.simScore;
     ocrText = m.ocrText;
     image = m.image;
     target = null;
     if (m.target != null) {
       target = new Location(m.target);
     }
     lastFindTime = m.lastFindTime;
     lastSearchTime = m.lastSearchTime;
   }
 
   /**
diff --git a/API/src/main/java/org/sikuli/script/OverlayCapturePrompt.java b/API/src/main/java/org/sikuli/script/OverlayCapturePrompt.java
index fe242c8..6328d64 100644
--- a/API/src/main/java/org/sikuli/script/OverlayCapturePrompt.java
+++ b/API/src/main/java/org/sikuli/script/OverlayCapturePrompt.java
@@ -13,116 +13,116 @@
 import java.awt.image.*;
 import org.sikuli.natives.SysUtil;
 
 /**
  * INTERNAL USE implements the screen overlay used with the capture feature
  */
 public class OverlayCapturePrompt extends OverlayTransparentWindow implements EventSubject {
 
   final static float MIN_DARKER_FACTOR = 0.6f;
   final static long MSG_DISPLAY_TIME = 2000;
   final static long WIN_FADE_IN_TIME = 200;
   static final Font fontMsg = new Font("Arial", Font.PLAIN, 60);
   static final Color selFrameColor = new Color(1.0f, 1.0f, 1.0f, 1.0f);
   static final Color selCrossColor = new Color(1.0f, 0.0f, 0.0f, 0.6f);
   static final Color screenFrameColor = new Color(1.0f, 0.0f, 0.0f, 0.6f);
   private Rectangle screenFrame = null;
   static final BasicStroke strokeScreenFrame = new BasicStroke(5);
   static final BasicStroke _StrokeCross = new BasicStroke(1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 1, new float[]{2f}, 0);
   static final BasicStroke bs = new BasicStroke(1);
   private EventObserver obs;
-  private Screen scrOCP;
+  private IScreen scrOCP;
   private BufferedImage scr_img = null;
   private BufferedImage scr_img_darker = null;
   private BufferedImage bi = null;
   private float darker_factor;
   private Rectangle rectSelection;
   private int srcScreenId = 0;
   private Location srcScreenLocation = null;
   private Location destScreenLocation = null;
   private int srcx, srcy, destx, desty;
   private boolean canceled = false;
   private String promptMsg;
   private boolean didPurgeMessage = false;
   private boolean dragging = false;
 
-  public OverlayCapturePrompt(Screen scr, EventObserver ob) {
+  public OverlayCapturePrompt(IScreen scr, EventObserver ob) {
     super();
     init(scr, ob);
   }
 
-  private void init(Screen scr, EventObserver ob) {
+  private void init(IScreen scr, EventObserver ob) {
     addObserver(ob);
     if (scr == null) {
       if (Screen.getNumberScreens() > 1) {
         scr = new ScreenUnion();
       } else {
         scr = Screen.getPrimaryScreen();
       }
     }
     scrOCP = scr;
     canceled = false;
     setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
     rectSelection = new Rectangle();
     addMouseListener(new MouseAdapter() {
 
       @Override
       public void mouseMoved(java.awt.event.MouseEvent e) {
         if (promptMsg == null) {
           return;
         }
         promptMsg = null;
         repaint();
       }
 
       @Override
       public void mousePressed(java.awt.event.MouseEvent e) {
         if (scr_img == null) {
           return;
         }
         if (promptMsg != null) {
           promptMsg = null;
           didPurgeMessage = true;
         }
         destx = srcx = e.getX();
         desty = srcy = e.getY();
         srcScreenId = scrOCP.getIdFromPoint(srcx, srcy);
-        srcScreenLocation = new Location(srcx + scrOCP.x, srcy + scrOCP.y);
+        srcScreenLocation = new Location(srcx + scrOCP.getX(), srcy + scrOCP.getY());
         Debug.log(2, "CapturePrompt: started at (%d,%d) as %s on %d", srcx, srcy,
                 srcScreenLocation.toStringShort(), srcScreenId);
         repaint();
       }
 
       @Override
       public void mouseReleased(java.awt.event.MouseEvent e) {
         if (scr_img == null) {
           return;
         }
         if (!dragging && didPurgeMessage) {
           didPurgeMessage = false;
           return;
         }
         if (e.getButton() == java.awt.event.MouseEvent.BUTTON3) {
           canceled = true;
           Debug.log(2, "CapturePrompt: aborted using right mouse button");
         } else {
-          destScreenLocation = new Location(destx + scrOCP.x, desty + scrOCP.y);
+          destScreenLocation = new Location(destx + scrOCP.getX(), desty + scrOCP.getY());
           Debug.log(2, "CapturePrompt: finished at (%d,%d) as %s on %d", destx, desty,
                   destScreenLocation.toStringShort(), srcScreenId);
         }
         setVisible(false);
         notifyObserver();
       }
     });
 
     addMouseMotionListener(new MouseMotionAdapter() {
       @Override
       public void mouseDragged(java.awt.event.MouseEvent e) {
         if (scr_img == null) {
           return;
         }
         dragging = true;
         destx = e.getX();
         desty = e.getY();
         repaint();
       }
     });
@@ -177,58 +177,58 @@
   }
 
   public void prompt() {
     prompt(null);
   }
 
   public void prompt(String msg) {
     captureScreen(scrOCP);
     this.setBounds(scrOCP.getBounds());
     promptMsg = msg;
     Debug.log(2, "CapturePrompt: " + promptMsg);
     this.setVisible(true);
     if (!Settings.isJava7()) {
       if (Settings.isMac()) {
         SysUtil.getOSUtil().bringWindowToFront(this, false);
       }
     }
     this.requestFocus();
   }
 
-  private void captureScreen(Screen scr) {
+  private void captureScreen(IScreen scr) {
     ScreenImage simg = scr.capture();
     scr_img = simg.getImage();
     darker_factor = 0.6f;
     RescaleOp op = new RescaleOp(darker_factor, 0, null);
     scr_img_darker = op.filter(scr_img, null);
   }
 
   public ScreenImage getSelection() {
     if (canceled) {
       return null;
     }
     BufferedImage cropImg = cropSelection();
     if (cropImg == null) {
       return null;
     }
-    rectSelection.x += scrOCP.x;
-    rectSelection.y += scrOCP.y;
+    rectSelection.x += scrOCP.getX();
+    rectSelection.y += scrOCP.getY();
     ScreenImage ret = new ScreenImage(rectSelection, cropImg);
     return ret;
   }
 
   private BufferedImage cropSelection() {
     int w = rectSelection.width, h = rectSelection.height;
     if (w <= 0 || h <= 0) {
       return null;
     }
     BufferedImage crop = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
     Graphics2D crop_g2d = crop.createGraphics();
     try {
       crop_g2d.drawImage(
               scr_img.getSubimage(rectSelection.x, rectSelection.y, w, h),
               null, 0, 0);
     } catch (RasterFormatException e) {
       Debug.error(e.getMessage());
     }
     crop_g2d.dispose();
     return crop;
@@ -288,34 +288,34 @@
     g2d.setStroke(strokeScreenFrame);
     if (screenFrame == null) {
       screenFrame = Screen.getBounds(scrId);
       Rectangle ubound = scrOCP.getBounds();
       screenFrame.x -= ubound.x;
       screenFrame.y -= ubound.y;
       int sw = (int) (strokeScreenFrame.getLineWidth() / 2);
       screenFrame.x += sw;
       screenFrame.y += sw;
       screenFrame.width -= sw * 2;
       screenFrame.height -= sw * 2;
     }
     g2d.draw(screenFrame);
   }
 
   @Override
   public void paint(Graphics g) {
     if (scr_img != null) {
       Graphics2D g2dWin = (Graphics2D) g;
       if (bi == null) {
-        bi = new BufferedImage(scrOCP.w,
-                scrOCP.h, BufferedImage.TYPE_INT_RGB);
+        bi = new BufferedImage(scrOCP.getW(),
+                scrOCP.getH(), BufferedImage.TYPE_INT_RGB);
       }
       Graphics2D bfG2 = bi.createGraphics();
       bfG2.drawImage(scr_img_darker, 0, 0, this);
       drawMessage(bfG2);
       drawSelection(bfG2);
       g2dWin.drawImage(bi, 0, 0, this);
       setVisible(true);
     } else {
       setVisible(false);
     }
   }
 }
diff --git a/API/src/main/java/org/sikuli/script/OverlayTransparentWindow.java b/API/src/main/java/org/sikuli/script/OverlayTransparentWindow.java
old mode 100755
new mode 100644
index 1838578..38c2c55
--- a/API/src/main/java/org/sikuli/script/OverlayTransparentWindow.java
+++ b/API/src/main/java/org/sikuli/script/OverlayTransparentWindow.java
@@ -92,41 +92,40 @@
   }
 
   public JPanel getJPanel() {
     return _panel;
   }
 
   public Graphics2D getJPanelGraphics() {
     return _currG2D;
   }
 
   @Override
   public void addObserver(EventObserver o) {
     _obs = o;
   }
 
   @Override
   public void notifyObserver() {
     _obs.update(this);
   }
 
-  @Override
   public void setOpacity(float alpha) {
     if (Settings.JavaVersion > 6) {
       try {
         Class<?> c = Class.forName("javax.swing.JFrame");
         Method m = c.getMethod("setOpacity", float.class);
         m.invoke(this, alpha);
       } catch (Exception e) {
         Debug.error("J7: TransparentWindow.setOpacity: did not work");
       }
     } else {
       try {
         if (__setWindowOpacity != null) {
           __setWindowOpacity.invoke(null, (Window) this, alpha);
         } else {
           Debug.error("J6: TransparentWindow.setOpacity: not initialized");
         }
       } catch (Exception e) {
         Debug.error("J6: TransparentWindow.setOpacity: did not work");
       }
     }
diff --git a/API/src/main/java/org/sikuli/script/Region.java b/API/src/main/java/org/sikuli/script/Region.java
index 3e2a8c8..812b4f4 100644
--- a/API/src/main/java/org/sikuli/script/Region.java
+++ b/API/src/main/java/org/sikuli/script/Region.java
@@ -1,58 +1,60 @@
 /*
  * Copyright 2010-2016, Sikuli.org, sikulix.com
  * Released under the MIT License.
  *
  * modified RaiMan
  */
 package org.sikuli.script;
 
 import java.awt.MouseInfo;
 import java.awt.Point;
 import java.awt.Rectangle;
 import java.awt.event.InputEvent;
 import java.awt.event.KeyEvent;
 import java.io.IOException;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import org.sikuli.basics.Debug;
 import org.sikuli.basics.Settings;
 
+import edu.unh.iol.dlc.VNCScreen;
+
 /**
  * A Region is a rectengular area and lies always completely inside its parent screen
  *
  */
 public class Region {
 
   private static String me = "Region";
   private static int lvl = 3;
 
   private static void log(int level, String message, Object... args) {
     Debug.logx(level, "", me + ": " + message, args);
   }
 
   /**
    * The Screen containing the Region
    */
-  private Screen scr;
-  private boolean otherScreen = false;
+  private IScreen scr;
+  protected boolean otherScreen = false;
 
   /**
    * The ScreenHighlighter for this Region
    */
   private ScreenHighlighter overlay = null;
   /**
    * X-coordinate of the Region
    */
   public int x;
   /**
    * Y-coordinate of the Region
    */
   public int y;
   /**
    * Width of the Region
    */
   public int w;
   /**
    * Height of the Region
    */
@@ -116,204 +118,231 @@
   public static final int WN = NW, WEST_NORTH = NW;
   public static final int WS = SW, WEST_SOUTH = SW;
 
   /**
    * to support a raster over the region
    */
   private int rows;
   private int cols = 0;
   private int rowH = 0;
   private int colW = 0;
   private int rowHd = 0;
   private int colWd = 0;
 
   /**
    * {@inheritDoc}
    *
    * @return the description
    */
   @Override
   public String toString() {
-    return String.format("R[%d,%d %dx%d]@%s E:%s, T:%.1f",
-            x, y, w, h, (getScreen() == null ? "Screen null" : getScreen().toStringShort()),
-            throwException ? "Y" : "N", autoWaitTimeout);
+	  
+	  return String.format("R[%d,%d %dx%d]@%s E:%s, T:%.1f",
+		            x, y, w, h, (getScreen() == null ? "Screen null" : getScreen().toStringShort()),
+		            throwException ? "Y" : "N", autoWaitTimeout);
   }
 
   /**
    *
    * @return a compact description
    */
   public String toStringShort() {
     return String.format("R[%d,%d %dx%d]@S(%s)", x, y, w, h, (getScreen() == null ? "?" : getScreen().getID()));
   }
 
   //<editor-fold defaultstate="collapsed" desc="OFF: Specials for scripting environment">
   /*
    public Object __enter__() {
    Debug.error("Region: with(__enter__): Trying to make it a Jython Region for with: usage");
    IScriptRunner runner = Settings.getScriptRunner("jython", null, null);
    if (runner != null) {
    Object[] jyreg = new Object[]{this};
    if (runner.doSomethingSpecial("createRegionForWith", jyreg)) {
    if (jyreg[0] != null) {
    return jyreg[0];
    }
    }
    }
    Debug.error("Region: with(__enter__): Sorry, not possible");
    return null;
    }
 
    public void __exit__(Object type, Object value, Object traceback) {
    Debug.error("Region: with(__exit__): Sorry, not a Jython Region and not posssible!");
    }
    */
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Initialization">
   /**
    * Detects on which Screen the Region is present. The region is cropped to the intersection with the given screen or
    * the screen with the largest intersection
    *
    * @param scr The Screen containing the Region
    */
-  public void initScreen(Screen scr) {
+  public void initScreen(IScreen scr) {
     // check given screen first
     Rectangle rect, screenRect;
-    Screen screen, screenOn;
+    IScreen screen, screenOn;
     if (scr != null) {
       if (scr.isOtherScreen()) {
         if (x < 0) {
           w = w + x;
           x = 0;
         }
         if (y < 0) {
           h = h + y;
           y = 0;
         }
         this.scr = scr;
         this.otherScreen = true;
         return;
       }
       if (scr.getID() > -1) {
         rect = regionOnScreen(scr);
         if (rect != null) {
           x = rect.x;
           y = rect.y;
           w = rect.width;
           h = rect.height;
           this.scr = scr;
           return;
         }
       } else {
         // is ScreenUnion
         return;
       }
     }
     // check all possible screens if no screen was given or the region is not on given screen
     // crop to the screen with the largest intersection
     screenRect = new Rectangle(0, 0, 0, 0);
     screenOn = null;
-    for (int i = 0; i < Screen.getNumberScreens(); i++) {
-      screen = Screen.getScreen(i);
-      rect = regionOnScreen(screen);
-      if (rect != null) {
-        if (rect.width * rect.height > screenRect.width * screenRect.height) {
-          screenRect = rect;
-          screenOn = screen;
+    if(scr instanceof Screen){
+    	for (int i = 0; i < Screen.getNumberScreens(); i++) {
+    		screen = Screen.getScreen(i);
+    		rect = regionOnScreen(screen);
+    		if (rect != null) {
+    			if (rect.width * rect.height > screenRect.width * screenRect.height) {
+    				screenRect = rect;
+    				screenOn = screen;
+    			}
+            }
         }
-      }
+    }
+    else if(scr instanceof VNCScreen){
+    	for (int i = 0; i < VNCScreen.getNumberScreens(); i++) {
+    		screen = VNCScreen.getScreen(i);
+    		rect = regionOnScreen(screen);
+    		if (rect != null) {
+    			if (rect.width * rect.height > screenRect.width * screenRect.height) {
+    				screenRect = rect;
+    				screenOn = screen;
+    			}
+            }
+        }
+    }
+    else{//when scr == null
+    	for (int i = 0; i < Screen.getNumberScreens(); i++) {
+    		screen = Screen.getScreen(i);
+    		rect = regionOnScreen(screen);
+    		if (rect != null) {
+    			if (rect.width * rect.height > screenRect.width * screenRect.height) {
+    				screenRect = rect;
+    				screenOn = screen;
+    			}
+            }
+        }
     }
     if (screenOn != null) {
       x = screenRect.x;
       y = screenRect.y;
       w = screenRect.width;
       h = screenRect.height;
       this.scr = screenOn;
     } else {
       // no screen found
       this.scr = null;
       Debug.error("Region(%d,%d,%d,%d) outside any screen - subsequent actions might not work as expected", x, y, w, h);
     }
   }
 
   private Location checkAndSetRemote(Location loc) {
     if (!isOtherScreen()) {
       return loc;
     }
     return loc.setOtherScreen(scr);
   }
 
   public boolean isOtherScreen() {
     return otherScreen;
   }
 
   public void setOtherScreen() {
     otherScreen = true;
   }
 
   /**
    * Checks if the Screen contains the Region.
    *
    * @param screen The Screen in which the Region might be
    * @return True, if the Region is on the Screen. False if the Region is not inside the Screen
    */
-  protected Rectangle regionOnScreen(Screen screen) {
-    if (screen == null) {
+  protected Rectangle regionOnScreen(IScreen screen) {
+	if (screen == null) {
       return null;
     }
     // get intersection of Region and Screen
     Rectangle rect = screen.getRect().intersection(getRect());
     // no Intersection, Region is not on the Screen
     if (rect.isEmpty()) {
-      return null;
+    	return null;
     }
     return rect;
   }
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Constructors to be used with Jython">
   /**
    * Create a region with the provided coordinate / size and screen
    *
    * @param X X position
    * @param Y Y position
    * @param W width
    * @param H heigth
    * @param screenNumber The number of the screen containing the Region
    */
   public Region(int X, int Y, int W, int H, int screenNumber) {
     this(X, Y, W, H, Screen.getScreen(screenNumber));
     this.rows = 0;
   }
 
   /**
    * Create a region with the provided coordinate / size and screen
    *
    * @param X X position
    * @param Y Y position
    * @param W width
    * @param H heigth
    * @param parentScreen the screen containing the Region
    */
-  public Region(int X, int Y, int W, int H, Screen parentScreen) {
-    this.rows = 0;
+  public Region(int X, int Y, int W, int H, IScreen parentScreen) {
+	this.rows = 0;
     this.x = X;
     this.y = Y;
     this.w = W > 1 ? W : 1;
     this.h = H > 1 ? H : 1;
     initScreen(parentScreen);
   }
 
   /**
    * Create a region with the provided coordinate / size
    *
    * @param X X position
    * @param Y Y position
    * @param W width
    * @param H heigth
    */
   public Region(int X, int Y, int W, int H) {
     this(X, Y, W, H, null);
     this.rows = 0;
     log(lvl, "init: (%d, %d, %d, %d)", X, Y, W, H);
   }
@@ -344,55 +373,55 @@
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Quasi-Constructors to be used in Java">
   /**
    * internal use only, used for new Screen objects to get the Region behavior
    */
   protected Region() {
     this.rows = 0;
   }
 
   /**
    * Create a region with the provided top left corner and size
    *
    * @param X top left X position
    * @param Y top left Y position
    * @param W width
    * @param H heigth
    * @return then new region
    */
   public static Region create(int X, int Y, int W, int H) {
-    return Region.create(X, Y, W, H, null);
+	return Region.create(X, Y, W, H, null);
   }
 
   /**
    * Create a region with the provided top left corner and size
    *
    * @param X top left X position
    * @param Y top left Y position
    * @param W width
    * @param H heigth
    * @param scr the source screen
    * @return the new region
    */
-  private static Region create(int X, int Y, int W, int H, Screen scr) {
-    return new Region(X, Y, W, H, scr);
+  private static Region create(int X, int Y, int W, int H, IScreen scr) {
+	return new Region(X, Y, W, H, scr);
   }
 
   /**
    * Create a region with the provided top left corner and size
    *
    * @param loc top left corner
    * @param w width
    * @param h height
    * @return then new region
    */
   public static Region create(Location loc, int w, int h) {
     return Region.create(loc.x, loc.y, w, h, loc.getScreen());
   }
   /**
    * Flag for the {@link #create(Location, int, int, int, int)} method. Sets the Location to be on the left corner of
    * the new Region.
    */
   public final static int CREATE_X_DIRECTION_LEFT = 0;
   /**
    * Flag for the {@link #create(Location, int, int, int, int)} method. Sets the Location to be on the right corner of
@@ -462,41 +491,41 @@
     return Region.create(loc, x, y, w, h);
   }
 
   /**
    * Create a region from a Rectangle
    *
    * @param r the Rectangle
    * @return the new region
    */
   public static Region create(Rectangle r) {
     return Region.create(r.x, r.y, r.width, r.height, null);
   }
 
   /**
    * Create a region from a Rectangle on a given Screen
    *
    * @param r the Rectangle
    * @param parentScreen the new parent screen
    * @return the new region
    */
-  protected static Region create(Rectangle r, Screen parentScreen) {
+  protected static Region create(Rectangle r, IScreen parentScreen) {
     return Region.create(r.x, r.y, r.width, r.height, parentScreen);
   }
 
   /**
    * Create a region from another region<br>including the region's settings
    *
    * @param r the region
    * @return then new region
    */
   public static Region create(Region r) {
     Region reg = Region.create(r.x, r.y, r.w, r.h, r.getScreen());
     reg.autoWaitTimeout = r.autoWaitTimeout;
     reg.findFailedResponse = r.findFailedResponse;
     reg.throwException = r.throwException;
     return reg;
   }
 
   /**
    * create a region with the given point as center and the given size
    *
@@ -542,41 +571,41 @@
   public boolean containsMouse() {
     return contains(atMouse());
   }
 
   /**
    * new region with same offset to current screen's top left on given screen
    *
    * @param scrID number of screen
    * @return new region
    */
   public Region copyTo(int scrID) {
     return copyTo(Screen.getScreen(scrID));
   }
 
   /**
    * new region with same offset to current screen's top left on given screen
    *
    * @param screen new parent screen
    * @return new region
    */
-  public Region copyTo(Screen screen) {
+  public Region copyTo(IScreen screen) {
     Location o = new Location(getScreen().getBounds().getLocation());
     Location n = new Location(screen.getBounds().getLocation());
     return Region.create(n.x + x - o.x, n.y + y - o.y, w, h, screen);
   }
 
   /**
    * used in Observer.callChangeObserving, Finder.next to adjust region relative coordinates of matches to
  screen coordinates
    *
    * @param m
    * @return the modified match
    */
   protected Match toGlobalCoord(Match m) {
     m.x += x;
     m.y += y;
     return m;
   }
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="handle Settings">
@@ -685,105 +714,106 @@
   public int getRepeatWaitTime() {
     return repeatWaitTime;
   }
 
   /**
    * set the regions individual WaitForVanish
    *
    * @param time in seconds
    */
   public void setRepeatWaitTime(int time) {
     repeatWaitTime = time;
   }
 
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="getters / setters / modificators">
   /**
    *
    * @return the Screen object containing the region
    */
-  public Screen getScreen() {
+  public IScreen getScreen() {
     return scr;
   }
 
   // to avoid NPE for Regions being outside any screen
   private IRobot getRobotForRegion() {
     if (getScreen() == null) {
       return Screen.getPrimaryScreen().getRobot();
     }
     return getScreen().getRobot();
   }
 
   /**
    *
    * @return the screen, that contains the top left corner of the region. Returns primary screen if outside of any
    * screen.
    * @deprecated Only for compatibility, to get the screen containing this region, use {@link #getScreen()}
    */
   @Deprecated
-  public Screen getScreenContaining() {
+  public IScreen getScreenContaining() {
     return getScreen();
   }
 
   /**
    * Sets a new Screen for this region.
    *
    * @param scr the containing screen object
 	 * @return
    */
-  protected Region setScreen(Screen scr) {
+  protected Region setScreen(IScreen scr) {
     initScreen(scr);
     return this;
   }
 
   /**
    * Sets a new Screen for this region.
    *
    * @param id the containing screen object's id
 	 * @return
    */
   protected Region setScreen(int id) {
     return setScreen(Screen.getScreen(id));
   }
 
   /**
    * synonym for showMonitors
    */
   public void showScreens() {
     Screen.showMonitors();
   }
 
   /**
    * synonym for resetMonitors
    */
   public void resetScreens() {
     Screen.resetMonitors();
   }
 
   // ************************************************
   /**
    *
    * @return the center pixel location of the region
    */
   public Location getCenter() {
-    return checkAndSetRemote(new Location(x + w / 2, y + h / 2));
+	  Location l = new Location(getX() + getW() / 2, getY() + getH() / 2);
+	  return checkAndSetRemote(l);
   }
 
   /**
    * convenience method
    *
    * @return the region's center
    */
   public Location getTarget() {
     return getCenter();
   }
 
   /**
    * Moves the region to the area, whose center is the given location
    *
    * @param loc the location which is the new center of the region
    * @return the region itself
    */
   public Region setCenter(Location loc) {
     Location c = getCenter();
     x = x - c.x + loc.x;
@@ -1956,41 +1986,41 @@
 		} else if (response == FindFailedResponse.ABORT) {
 			String targetStr = target.toString();
 			if (target instanceof String) {
 				targetStr = targetStr.trim();
 			}
 			throw new FindFailed(String.format("can not find %s in %s", targetStr, this.toStringShort()));
 		}
     return false;
   }
 
   /**
    * finds the given Pattern, String or Image in the region and returns the best match. If AutoWaitTimeout
    * is set, this is equivalent to wait(). Otherwise only one search attempt will be done.
    *
    * @param target A search criteria
    * @return If found, the element. null otherwise
    * @throws FindFailed if the Find operation failed
    */
   public <PSI> Match find(PSI target) throws FindFailed {
     if (autoWaitTimeout > 0) {
-      return wait(target, autoWaitTimeout);
+    	return wait(target, autoWaitTimeout);
     }
     lastMatch = null;
 		String targetStr = target.toString();
 		if (target instanceof String) {
 			targetStr = targetStr.trim();
 		}
     while (true) {
       try {
         log(2, "find: waiting 0 secs for %s to appear in %s", targetStr, this.toStringShort());
         lastMatch = doFind(target, null);
       } catch (IOException ex) {
         if (ex instanceof IOException) {
           if (handleFindFailedImageMissing(target)) {
             continue;
           }
         }
         throw new FindFailed(ex.getMessage());
       }
       if (lastMatch != null) {
         Image img = getImage(target);
@@ -2310,41 +2340,52 @@
         SikuliX.endFatal(1);
       }
       if (repeating != null) {
         repeating._finder = f;
         repeating._image = img;
       }
     }
     lastSearchTime = (new Date()).getTime() - lastSearchTime;
     lastFindTime = (new Date()).getTime() - lastFindTime;
     if (f.hasNext()) {
       m = f.next();
       m.setTimes(lastFindTime, lastSearchTime);
     }
     return m;
   }
 
   private Finder checkLastSeenAndCreateFinder(Image img, double findTimeout, Pattern ptn) {
     if (!Settings.UseImageFinder && Settings.CheckLastSeen && null != img.getLastSeen()) {
       Region r = Region.create(img.getLastSeen());
       if (this.contains(r)) {
-        Finder f = new Finder(new Screen().capture(r), r);
+        Finder f = null;
+        
+        if(this.scr instanceof Screen){
+        	f = new Finder(new Screen().capture(r), r);
+        }
+        else if(this.scr instanceof VNCScreen){
+        	f = new Finder(new VNCScreen().capture(r), r);
+        }
+        else{
+        	f = new Finder(new Screen().capture(r), r);
+        }
+        
         if (ptn == null) {
           f.find(new Pattern(img).similar(Settings.CheckLastSeenSimilar));
         } else {
           f.find(new Pattern(ptn).similar(Settings.CheckLastSeenSimilar));
         }
         if (f.hasNext()) {
           log(lvl, "checkLastSeen: still there");
           return f;
         }
         log(lvl, "checkLastSeen: not there");
       }
     }
     if (Settings.UseImageFinder) {
       ImageFinder f = new ImageFinder(this);
       f.setFindTimeout(findTimeout);
       return f;
     } else {
       return new Finder(getScreen().capture(x, y, w, h), this);
     }
   }
@@ -2523,43 +2564,45 @@
   //<editor-fold defaultstate="collapsed" desc="Find internal support">
 //  private <PatternStringRegionMatch> Region getRegionFromTarget(PatternStringRegionMatch target) throws FindFailed {
 //    if (target instanceof Pattern || target instanceof String || target instanceof Image) {
 //      Match m = find(target);
 //      if (m != null) {
 //        return m.setScreen(scr);
 //      }
 //      return null;
 //    }
 //    if (target instanceof Region) {
 //      return ((Region) target).setScreen(scr);
 //    }
 //    return null;
 //  }
 
   private <PSIMRL> Location getLocationFromTarget(PSIMRL target) throws FindFailed {
     if (target instanceof Pattern || target instanceof String || target instanceof Image) {
       Match m = find(target);
       if (m != null) {
         if (isOtherScreen()) {
-          return m.getTarget().setOtherScreen(scr);
+        	Location location = m.getTarget();
+        	location = location.setOtherScreen(scr);
+          return location;
         } else {
-          return m.getTarget();
+        	return m.getTarget();
         }
       }
       return null;
     }
     if (target instanceof Match) {
       return ((Match) target).getTarget();
     }
     if (target instanceof Region) {
       return ((Region) target).getCenter();
     }
     if (target instanceof Location) {
       return new Location((Location) target);
     }
     return null;
   }
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Observing">
   public Observer getObserver() {
     if (regionObserver == null) {
diff --git a/API/src/main/java/org/sikuli/script/Screen.java b/API/src/main/java/org/sikuli/script/Screen.java
index 5cc861f..f469ba9 100644
--- a/API/src/main/java/org/sikuli/script/Screen.java
+++ b/API/src/main/java/org/sikuli/script/Screen.java
@@ -195,73 +195,73 @@
 	 * reset from being a screen union to the screen used before
 	 */
   public void setAsScreen() {
     curID = oldID;
   }
 
   /**
    * Is the screen object having the top left corner as (0,0). If such a screen does not exist it is
    * the screen with id 0.
    */
   public Screen() {
     super();
     curID = primaryScreen;
     initScreen();
   }
 
   /**
    * {@inheritDoc} TODO: remove this method if it is not needed
    */
   @Override
-  public void initScreen(Screen scr) {
+  public void initScreen(IScreen scr) {
     updateSelf();
   }
 
   private void initScreen() {
     curGD = gdevs[curID];
     Rectangle bounds = getBounds();
     x = (int) bounds.getX();
     y = (int) bounds.getY();
     w = (int) bounds.getWidth();
     h = (int) bounds.getHeight();
     try {
       robot = new RobotDesktop(this);
       robot.setAutoDelay(10);
     } catch (AWTException e) {
       Debug.error("Can't initialize Java Robot on Screen " + curID + ": " + e.getMessage());
       robot = null;
     }
   }
 
   /**
    * {@inheritDoc}
    */
   @Override
   public Screen getScreen() {
     return this;
   }
 
   /**
    * {@inheritDoc}
    */
   @Override
-  protected Region setScreen(Screen s) {
+  protected Region setScreen(IScreen s) {
     throw new UnsupportedOperationException("The setScreen() method cannot be called from a Screen object.");
   }
 
   /**
    * show the current monitor setup
    */
   public static void showMonitors() {
 //    initScreens();
     Debug.info("*** monitor configuration [ %s Screen(s)] ***", Screen.getNumberScreens());
     Debug.info("*** Primary is Screen %d", primaryScreen);
     for (int i = 0; i < gdevs.length; i++) {
       Debug.info("Screen %d: %s", i, Screen.getScreen(i).toStringShort());
     }
     Debug.info("*** end monitor configuration ***");
   }
 
   /**
    * re-initialize the monitor setup (e.g. when it was changed while running)
    */
   public static void resetMonitors() {
@@ -281,104 +281,106 @@
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="getters setters">
   protected boolean useFullscreen() {
     return false;
   }
 
   private static int getValidID(int id) {
     if (id < 0 || id >= gdevs.length) {
       Debug.error("Screen: invalid screen id %d - using primary screen", id);
       return primaryScreen;
     }
     return id;
   }
 
   /**
    *
    * @return number of available screens
    */
   public static int getNumberScreens() {
-    return gdevs.length;
+	 return gdevs.length;
   }
 
   /**
    *
    * @return the id of the screen at (0,0), if not exists 0
    */
   public static int getPrimaryId() {
     return primaryScreen;
   }
 
   /**
    *
    * @return the screen at (0,0), if not exists the one with id 0
    */
   public static Screen getPrimaryScreen() {
     return screens[primaryScreen];
   }
 
   /**
    *
    * @param id of the screen
    * @return the screen with given id, the primary screen if id is invalid
    */
   public static Screen getScreen(int id) {
-    return screens[getValidID(id)];
+	return screens[getValidID(id)];
   }
 
   /**
    *
    * @param id
    * @return the physical coordinate/size <br>as AWT.Rectangle to avoid mix up with getROI
    */
   public static Rectangle getBounds(int id) {
     return gdevsBounds[getValidID(id)];
   }
 
   /**
    * each screen has exactly one robot (internally used for screen capturing)
    * <br>available as a convenience for those who know what they are doing. Should not be needed
    * normally.
    *
    * @param id
    * @return the AWT.Robot of the given screen, if id invalid the primary screen
    */
   public static IRobot getRobot(int id) {
     return getScreen(id).getRobot();
   }
 
   /**
    *
 	 * @return the id
    */
+  @Override
   public int getID() {
     return curID;
   }
 
   /**
    * INTERNAL USE: to be compatible with ScreenUnion
    * @param x
    * @param y
    * @return
    */
-  protected int getIdFromPoint(int x, int y) {
+  @Override
+  public int getIdFromPoint(int x, int y) {
     return curID;
   }
 
   /**
    *
 	 * @return active GraphicsDevice
    */
   public GraphicsDevice getGraphicsDevice() {
     return curGD;
   }
 
   /**
    * Gets the Robot of this Screen.
    *
    * @return The Robot for this Screen
    */
   @Override
   public IRobot getRobot() {
     return robot;
   }
@@ -388,41 +390,42 @@
 	 */
   @Override
   public Rectangle getBounds() {
     return gdevsBounds[curID];
   }
 
   /**
    * creates a region on the current screen with the given coordinate/size. The coordinate is
    * translated to the current screen from its relative position on the screen it would have been
    * created normally.
    *
    * @param loc
    * @param width
    * @param height
    * @return the new region
    */
   public Region newRegion(Location loc, int width, int height) {
     return Region.create(loc.copyTo(this), width, height);
   }
 
-  protected ScreenImage getLastScreenImageFromScreen() {
+  @Override
+  public ScreenImage getLastScreenImageFromScreen() {
     return lastScreenImage;
   }
   /**
    * creates a location on the current screen with the given point. The coordinate is translated to
    * the current screen from its relative position on the screen it would have been created
    * normally.
    *
    * @param loc
    * @return the new location
    */
   public Location newLocation(Location loc) {
     return (new Location(loc)).copyTo(this);
   }
 
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Capture - SelectRegion">
   /**
    * create a ScreenImage with the physical bounds of this screen
    *
@@ -472,40 +475,41 @@
   public ScreenImage capture(Region reg) {
     return capture(reg.getRect());
   }
 
   /**
    * interactive capture with predefined message: lets the user capture a screen image using the
    * mouse to draw the rectangle
    *
    * @return the image
    */
   public ScreenImage userCapture() {
     return userCapture(promptMsg);
   }
 
   /**
    * interactive capture with given message: lets the user capture a screen image using the mouse to
    * draw the rectangle
    *
    * @return the image
    */
+  @Override
   public ScreenImage userCapture(final String msg) {
     waitPrompt = true;
     Thread th = new Thread() {
       @Override
       public void run() {
         if ("".equals(msg)) {
           prompt = new OverlayCapturePrompt(null, Screen.this);
           prompt.prompt(promptMsg);
        } else {
           prompt = new OverlayCapturePrompt(Screen.this, Screen.this);
           prompt.prompt(msg);
         }
       }
     };
     th.start();
     try {
       int count = 0;
       while (waitPrompt) {
         Thread.sleep(100);
         if (count++ > waitForScreenshot) {
@@ -541,53 +545,84 @@
     if (sim == null) {
       return null;
     }
     Rectangle r = sim.getROI();
     return Region.create((int) r.getX(), (int) r.getY(),
             (int) r.getWidth(), (int) r.getHeight());
   }
 
   /**
    * Internal use only
    *
    * @param s
    */
   @Override
   public void update(EventSubject s) {
     waitPrompt = false;
   }
   //</editor-fold>
 
   //<editor-fold defaultstate="collapsed" desc="Visual effects">
-  protected void showTarget(Location loc) {
+  @Override
+  public void showTarget(Location loc) {
     showTarget(loc, Settings.SlowMotionDelay);
   }
 
   protected void showTarget(Location loc, double secs) {
     if (Settings.isShowActions()) {
       ScreenHighlighter overlay = new ScreenHighlighter(this, null);
       overlay.showTarget(loc, (float) secs);
     }
   }
   //</editor-fold>
 
   @Override
+  public Rectangle getRect(){
+	  return new Rectangle(x, y, w, h);
+  }
+  
+	@Override
+	public boolean isOtherScreen(){
+		return otherScreen;
+	}
+	
+	@Override
+	public int getX(){
+		return (int) getBounds().getX();
+	}
+	
+	@Override
+	public int getY(){
+		return (int) getBounds().getY();
+	}
+	
+	@Override
+	public int getW(){
+		return (int) getBounds().getWidth();
+	}
+	
+	@Override
+	public int getH(){
+		return (int) getBounds().getHeight();
+	}
+  
+  @Override
   public String toString() {
     Rectangle r = getBounds();
     return String.format("S(%d)[%d,%d %dx%d] E:%s, T:%.1f",
             curID, (int) r.getX(), (int) r.getY(),
             (int) r.getWidth(), (int) r.getHeight(),
             getThrowException() ? "Y" : "N", getAutoWaitTimeout());
   }
 
   /**
    * only a short version of toString()
    *
    * @return like S(0) [0,0, 1440x900]
    */
   @Override
   public String toStringShort() {
     Rectangle r = getBounds();
     return String.format("S(%d)[%d,%d %dx%d]",
             curID, (int) r.getX(), (int) r.getY(),
             (int) r.getWidth(), (int) r.getHeight());
   }
diff --git a/API/src/main/java/org/sikuli/script/ScreenHighlighter.java b/API/src/main/java/org/sikuli/script/ScreenHighlighter.java
index 761272c..db05615 100644
--- a/API/src/main/java/org/sikuli/script/ScreenHighlighter.java
+++ b/API/src/main/java/org/sikuli/script/ScreenHighlighter.java
@@ -10,56 +10,56 @@
 import org.sikuli.basics.Settings;
 import org.sikuli.basics.Debug;
 import java.awt.*;
 import java.awt.event.*;
 import java.awt.image.*;
 import java.util.HashSet;
 import java.util.Set;
 import java.lang.reflect.Field;
 
 /**
  * INTERNAL USE produces and manages the red framed rectangles from Region.highlight()
  */
 public class ScreenHighlighter extends OverlayTransparentWindow implements MouseListener {
 
   static Color _transparentColor = new Color(0F, 0F, 0F, 0.5F);
   Color _targetColor = Color.RED;
   final static int TARGET_SIZE = 50;
   final static int DRAGGING_TIME = 200;
   static int MARGIN = 20;
   static Set<ScreenHighlighter> _opened = new HashSet<ScreenHighlighter>();
-  Screen _scr;
+  IScreen _scr;
   BufferedImage _screen = null;
   BufferedImage _darker_screen = null;
   BufferedImage bi = null;
   int srcx, srcy, destx, desty;
   Location _lastTarget;
   boolean _borderOnly = false;
   boolean _native_transparent = false;
   boolean _double_buffered = false;
   Animator _anim;
   BasicStroke _StrokeCross = new BasicStroke(1);
   BasicStroke _StrokeCircle = new BasicStroke(2);
   BasicStroke _StrokeBorder = new BasicStroke(3);
   Animator _aniX, _aniY;
 
-  public ScreenHighlighter(Screen scr, String color) {
+  public ScreenHighlighter(IScreen scr, String color) {
     _scr = scr;
     init();
     setVisible(false);
     setAlwaysOnTop(true);
 
     if (color != null) {
       // a frame color is specified
       // if not decodable, then predefined Color.RED is used
       if (color.startsWith("#")) {
         if (color.length() > 7) {
           // might be the version #nnnnnnnnn
           if (color.length() == 10) {
             int cR = 255, cG = 0, cB = 0;
             try {
               cR = Integer.decode(color.substring(1, 4));
               cG = Integer.decode(color.substring(4, 7));
               cB = Integer.decode(color.substring(7, 10));
             } catch (NumberFormatException ex) {
             }
             try {
